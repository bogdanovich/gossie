// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"bytes"
	"reflect"
	"database/sql/driver"
	"errors"
	"context"
	"fmt"
	"github.com/bogdanovich/go-thrift/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = reflect.DeepEqual
var _ = bytes.Equal

//The ConsistencyLevel is an enum that controls both read and write
//behavior based on the ReplicationFactor of the keyspace.  The
//different consistency levels have different meanings, depending on
//if you're doing a write or read operation.
//
//If W + R > ReplicationFactor, where W is the number of nodes to
//block for on write, and R the number to block for on reads, you
//will have strongly consistent behavior; that is, readers will
//always see the most recent write. Of these, the most interesting is
//to do QUORUM reads and writes, which gives you consistency while
//still allowing availability in the face of node failures up to half
//of <ReplicationFactor>. Of course if latency is more important than
//consistency then you can use lower values for either or both.
//
//Some ConsistencyLevels (ONE, TWO, THREE) refer to a specific number
//of replicas rather than a logical concept that adjusts
//automatically with the replication factor.  Of these, only ONE is
//commonly used; TWO and (even more rarely) THREE are only useful
//when you care more about guaranteeing a certain level of
//durability, than consistency.
//
//Write consistency levels make the following guarantees before reporting success to the client:
//  ANY          Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
//  ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
//  TWO          Ensure that the write has been written to at least 2 node's commit log and memory table
//  THREE        Ensure that the write has been written to at least 3 node's commit log and memory table
//  QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
//  LOCAL_ONE    Ensure that the write has been written to 1 node within the local datacenter (requires NetworkTopologyStrategy)
//  LOCAL_QUORUM Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires NetworkTopologyStrategy)
//  EACH_QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires NetworkTopologyStrategy)
//  ALL          Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
//
//Read consistency levels make the following guarantees before returning successful results to the client:
//  ANY          Not supported. You probably want ONE instead.
//  ONE          Returns the record obtained from a single replica.
//  TWO          Returns the record with the most recent timestamp once two replicas have replied.
//  THREE        Returns the record with the most recent timestamp once three replicas have replied.
//  QUORUM       Returns the record with the most recent timestamp once a majority of replicas have replied.
//  LOCAL_ONE    Returns the record with the most recent timestamp once a single replica within the local datacenter have replied.
//  LOCAL_QUORUM Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
//  EACH_QUORUM  Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
//  ALL          Returns the record with the most recent timestamp once all replicas have replied (implies no replica may be down)..
type ConsistencyLevel int64
const (
  ConsistencyLevel_ONE ConsistencyLevel = 1
  ConsistencyLevel_QUORUM ConsistencyLevel = 2
  ConsistencyLevel_LOCAL_QUORUM ConsistencyLevel = 3
  ConsistencyLevel_EACH_QUORUM ConsistencyLevel = 4
  ConsistencyLevel_ALL ConsistencyLevel = 5
  ConsistencyLevel_ANY ConsistencyLevel = 6
  ConsistencyLevel_TWO ConsistencyLevel = 7
  ConsistencyLevel_THREE ConsistencyLevel = 8
  ConsistencyLevel_SERIAL ConsistencyLevel = 9
  ConsistencyLevel_LOCAL_SERIAL ConsistencyLevel = 10
  ConsistencyLevel_LOCAL_ONE ConsistencyLevel = 11
)

func (p ConsistencyLevel) String() string {
  switch p {
  case ConsistencyLevel_ONE: return "ONE"
  case ConsistencyLevel_QUORUM: return "QUORUM"
  case ConsistencyLevel_LOCAL_QUORUM: return "LOCAL_QUORUM"
  case ConsistencyLevel_EACH_QUORUM: return "EACH_QUORUM"
  case ConsistencyLevel_ALL: return "ALL"
  case ConsistencyLevel_ANY: return "ANY"
  case ConsistencyLevel_TWO: return "TWO"
  case ConsistencyLevel_THREE: return "THREE"
  case ConsistencyLevel_SERIAL: return "SERIAL"
  case ConsistencyLevel_LOCAL_SERIAL: return "LOCAL_SERIAL"
  case ConsistencyLevel_LOCAL_ONE: return "LOCAL_ONE"
  }
  return "<UNSET>"
}

func ConsistencyLevelFromString(s string) (ConsistencyLevel, error) {
  switch s {
  case "ONE": return ConsistencyLevel_ONE, nil 
  case "QUORUM": return ConsistencyLevel_QUORUM, nil 
  case "LOCAL_QUORUM": return ConsistencyLevel_LOCAL_QUORUM, nil 
  case "EACH_QUORUM": return ConsistencyLevel_EACH_QUORUM, nil 
  case "ALL": return ConsistencyLevel_ALL, nil 
  case "ANY": return ConsistencyLevel_ANY, nil 
  case "TWO": return ConsistencyLevel_TWO, nil 
  case "THREE": return ConsistencyLevel_THREE, nil 
  case "SERIAL": return ConsistencyLevel_SERIAL, nil 
  case "LOCAL_SERIAL": return ConsistencyLevel_LOCAL_SERIAL, nil 
  case "LOCAL_ONE": return ConsistencyLevel_LOCAL_ONE, nil 
  }
  return ConsistencyLevel(0), fmt.Errorf("not a valid ConsistencyLevel string")
}


func ConsistencyLevelPtr(v ConsistencyLevel) *ConsistencyLevel { return &v }

func (p ConsistencyLevel) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ConsistencyLevel) UnmarshalText(text []byte) error {
q, err := ConsistencyLevelFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ConsistencyLevel) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ConsistencyLevel(v)
return nil
}

func (p * ConsistencyLevel) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type IndexOperator int64
const (
  IndexOperator_EQ IndexOperator = 0
  IndexOperator_GTE IndexOperator = 1
  IndexOperator_GT IndexOperator = 2
  IndexOperator_LTE IndexOperator = 3
  IndexOperator_LT IndexOperator = 4
)

func (p IndexOperator) String() string {
  switch p {
  case IndexOperator_EQ: return "EQ"
  case IndexOperator_GTE: return "GTE"
  case IndexOperator_GT: return "GT"
  case IndexOperator_LTE: return "LTE"
  case IndexOperator_LT: return "LT"
  }
  return "<UNSET>"
}

func IndexOperatorFromString(s string) (IndexOperator, error) {
  switch s {
  case "EQ": return IndexOperator_EQ, nil 
  case "GTE": return IndexOperator_GTE, nil 
  case "GT": return IndexOperator_GT, nil 
  case "LTE": return IndexOperator_LTE, nil 
  case "LT": return IndexOperator_LT, nil 
  }
  return IndexOperator(0), fmt.Errorf("not a valid IndexOperator string")
}


func IndexOperatorPtr(v IndexOperator) *IndexOperator { return &v }

func (p IndexOperator) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *IndexOperator) UnmarshalText(text []byte) error {
q, err := IndexOperatorFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *IndexOperator) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = IndexOperator(v)
return nil
}

func (p * IndexOperator) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type IndexType int64
const (
  IndexType_KEYS IndexType = 0
  IndexType_CUSTOM IndexType = 1
  IndexType_COMPOSITES IndexType = 2
)

func (p IndexType) String() string {
  switch p {
  case IndexType_KEYS: return "KEYS"
  case IndexType_CUSTOM: return "CUSTOM"
  case IndexType_COMPOSITES: return "COMPOSITES"
  }
  return "<UNSET>"
}

func IndexTypeFromString(s string) (IndexType, error) {
  switch s {
  case "KEYS": return IndexType_KEYS, nil 
  case "CUSTOM": return IndexType_CUSTOM, nil 
  case "COMPOSITES": return IndexType_COMPOSITES, nil 
  }
  return IndexType(0), fmt.Errorf("not a valid IndexType string")
}


func IndexTypePtr(v IndexType) *IndexType { return &v }

func (p IndexType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *IndexType) UnmarshalText(text []byte) error {
q, err := IndexTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *IndexType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = IndexType(v)
return nil
}

func (p * IndexType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//CQL query compression
type Compression int64
const (
  Compression_GZIP Compression = 1
  Compression_NONE Compression = 2
)

func (p Compression) String() string {
  switch p {
  case Compression_GZIP: return "GZIP"
  case Compression_NONE: return "NONE"
  }
  return "<UNSET>"
}

func CompressionFromString(s string) (Compression, error) {
  switch s {
  case "GZIP": return Compression_GZIP, nil 
  case "NONE": return Compression_NONE, nil 
  }
  return Compression(0), fmt.Errorf("not a valid Compression string")
}


func CompressionPtr(v Compression) *Compression { return &v }

func (p Compression) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Compression) UnmarshalText(text []byte) error {
q, err := CompressionFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Compression) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Compression(v)
return nil
}

func (p * Compression) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type CqlResultType int64
const (
  CqlResultType_ROWS CqlResultType = 1
  CqlResultType_VOID CqlResultType = 2
  CqlResultType_INT CqlResultType = 3
)

func (p CqlResultType) String() string {
  switch p {
  case CqlResultType_ROWS: return "ROWS"
  case CqlResultType_VOID: return "VOID"
  case CqlResultType_INT: return "INT"
  }
  return "<UNSET>"
}

func CqlResultTypeFromString(s string) (CqlResultType, error) {
  switch s {
  case "ROWS": return CqlResultType_ROWS, nil 
  case "VOID": return CqlResultType_VOID, nil 
  case "INT": return CqlResultType_INT, nil 
  }
  return CqlResultType(0), fmt.Errorf("not a valid CqlResultType string")
}


func CqlResultTypePtr(v CqlResultType) *CqlResultType { return &v }

func (p CqlResultType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *CqlResultType) UnmarshalText(text []byte) error {
q, err := CqlResultTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *CqlResultType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = CqlResultType(v)
return nil
}

func (p * CqlResultType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Basic unit of data within a ColumnFamily.
// @param name, the name by which this column is set and retrieved.  Maximum 64KB long.
// @param value. The data associated with the name.  Maximum 2GB long, but in practice you should limit it to small numbers of MB (since Thrift must read the full value into memory to operate on it).
// @param timestamp. The timestamp is used for conflict detection/resolution when two columns with same name need to be compared.
// @param ttl. An optional, positive delay (in seconds) after which the column will be automatically deleted.
// 
// Attributes:
//  - Name
//  - Value
//  - Timestamp
//  - TTL
type Column struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  Value []byte `thrift:"value,2" db:"value" json:"value,omitempty"`
  Timestamp *int64 `thrift:"timestamp,3" db:"timestamp" json:"timestamp,omitempty"`
  TTL *int32 `thrift:"ttl,4" db:"ttl" json:"ttl,omitempty"`
}

func NewColumn() *Column {
  return &Column{}
}


func (p *Column) GetName() []byte {
  return p.Name
}
var Column_Value_DEFAULT []byte

func (p *Column) GetValue() []byte {
  return p.Value
}
var Column_Timestamp_DEFAULT int64
func (p *Column) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return Column_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var Column_TTL_DEFAULT int32
func (p *Column) GetTTL() int32 {
  if !p.IsSetTTL() {
    return Column_TTL_DEFAULT
  }
return *p.TTL
}
func (p *Column) IsSetValue() bool {
  return p.Value != nil
}

func (p *Column) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *Column) IsSetTTL() bool {
  return p.TTL != nil
}

func (p *Column) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *Column)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Column)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *Column)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *Column)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TTL = &v
}
  return nil
}

func (p *Column) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Column"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Column) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Column) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetValue() {
    if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
    if err := oprot.WriteBinary(p.Value); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  }
  return err
}

func (p *Column) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
    if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  }
  return err
}

func (p *Column) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetTTL() {
    if err := oprot.WriteFieldBegin("ttl", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ttl: ", p), err) }
    if err := oprot.WriteI32(int32(*p.TTL)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ttl (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ttl: ", p), err) }
  }
  return err
}

func (p *Column) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Column(%+v)", *p)
}

// A named list of columns.
// @param name. see Column.name.
// @param columns. A collection of standard Columns.  The columns within a super column are defined in an adhoc manner.
//                 Columns within a super column do not have to have matching structures (similarly named child columns).
// 
// Attributes:
//  - Name
//  - Columns
type SuperColumn struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  Columns []*Column `thrift:"columns,2,required" db:"columns" json:"columns"`
}

func NewSuperColumn() *SuperColumn {
  return &SuperColumn{}
}


func (p *SuperColumn) GetName() []byte {
  return p.Name
}

func (p *SuperColumn) GetColumns() []*Column {
  return p.Columns
}
func (p *SuperColumn) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumns = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *SuperColumn)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *SuperColumn)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Column, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &Column{}
    if err := _elem0.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Columns = append(p.Columns, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SuperColumn) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("SuperColumn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *SuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *SuperColumn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SuperColumn(%+v)", *p)
}

// Attributes:
//  - Name
//  - Value
type CounterColumn struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  Value int64 `thrift:"value,2,required" db:"value" json:"value"`
}

func NewCounterColumn() *CounterColumn {
  return &CounterColumn{}
}


func (p *CounterColumn) GetName() []byte {
  return p.Name
}

func (p *CounterColumn) GetValue() int64 {
  return p.Value
}
func (p *CounterColumn) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetValue bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValue = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetValue{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"));
  }
  return nil
}

func (p *CounterColumn)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CounterColumn)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *CounterColumn) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CounterColumn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CounterColumn) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *CounterColumn) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("value", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
  if err := oprot.WriteI64(int64(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  return err
}

func (p *CounterColumn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CounterColumn(%+v)", *p)
}

// Attributes:
//  - Name
//  - Columns
type CounterSuperColumn struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  Columns []*CounterColumn `thrift:"columns,2,required" db:"columns" json:"columns"`
}

func NewCounterSuperColumn() *CounterSuperColumn {
  return &CounterSuperColumn{}
}


func (p *CounterSuperColumn) GetName() []byte {
  return p.Name
}

func (p *CounterSuperColumn) GetColumns() []*CounterColumn {
  return p.Columns
}
func (p *CounterSuperColumn) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumns = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *CounterSuperColumn)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CounterSuperColumn)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CounterColumn, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem1 := &CounterColumn{}
    if err := _elem1.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
    }
    p.Columns = append(p.Columns, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CounterSuperColumn) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CounterSuperColumn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CounterSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *CounterSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *CounterSuperColumn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CounterSuperColumn(%+v)", *p)
}

// Methods for fetching rows/records from Cassandra will return either a single instance of ColumnOrSuperColumn or a list
// of ColumnOrSuperColumns (get_slice()). If you're looking up a SuperColumn (or list of SuperColumns) then the resulting
// instances of ColumnOrSuperColumn will have the requested SuperColumn in the attribute super_column. For queries resulting
// in Columns, those values will be in the attribute column. This change was made between 0.3 and 0.4 to standardize on
// single query methods that may return either a SuperColumn or Column.
// 
// If the query was on a counter column family, you will either get a counter_column (instead of a column) or a
// counter_super_column (instead of a super_column)
// 
// @param column. The Column returned by get() or get_slice().
// @param super_column. The SuperColumn returned by get() or get_slice().
// @param counter_column. The Counterolumn returned by get() or get_slice().
// @param counter_super_column. The CounterSuperColumn returned by get() or get_slice().
// 
// Attributes:
//  - Column
//  - SuperColumn
//  - CounterColumn
//  - CounterSuperColumn
type ColumnOrSuperColumn struct {
  Column *Column `thrift:"column,1" db:"column" json:"column,omitempty"`
  SuperColumn *SuperColumn `thrift:"super_column,2" db:"super_column" json:"super_column,omitempty"`
  CounterColumn *CounterColumn `thrift:"counter_column,3" db:"counter_column" json:"counter_column,omitempty"`
  CounterSuperColumn *CounterSuperColumn `thrift:"counter_super_column,4" db:"counter_super_column" json:"counter_super_column,omitempty"`
}

func NewColumnOrSuperColumn() *ColumnOrSuperColumn {
  return &ColumnOrSuperColumn{}
}

var ColumnOrSuperColumn_Column_DEFAULT *Column
func (p *ColumnOrSuperColumn) GetColumn() *Column {
  if !p.IsSetColumn() {
    return ColumnOrSuperColumn_Column_DEFAULT
  }
return p.Column
}
var ColumnOrSuperColumn_SuperColumn_DEFAULT *SuperColumn
func (p *ColumnOrSuperColumn) GetSuperColumn() *SuperColumn {
  if !p.IsSetSuperColumn() {
    return ColumnOrSuperColumn_SuperColumn_DEFAULT
  }
return p.SuperColumn
}
var ColumnOrSuperColumn_CounterColumn_DEFAULT *CounterColumn
func (p *ColumnOrSuperColumn) GetCounterColumn() *CounterColumn {
  if !p.IsSetCounterColumn() {
    return ColumnOrSuperColumn_CounterColumn_DEFAULT
  }
return p.CounterColumn
}
var ColumnOrSuperColumn_CounterSuperColumn_DEFAULT *CounterSuperColumn
func (p *ColumnOrSuperColumn) GetCounterSuperColumn() *CounterSuperColumn {
  if !p.IsSetCounterSuperColumn() {
    return ColumnOrSuperColumn_CounterSuperColumn_DEFAULT
  }
return p.CounterSuperColumn
}
func (p *ColumnOrSuperColumn) IsSetColumn() bool {
  return p.Column != nil
}

func (p *ColumnOrSuperColumn) IsSetSuperColumn() bool {
  return p.SuperColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterColumn() bool {
  return p.CounterColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterSuperColumn() bool {
  return p.CounterSuperColumn != nil
}

func (p *ColumnOrSuperColumn) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ColumnOrSuperColumn)  ReadField1(iprot thrift.TProtocol) error {
  p.Column = &Column{}
  if err := p.Column.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
  }
  return nil
}

func (p *ColumnOrSuperColumn)  ReadField2(iprot thrift.TProtocol) error {
  p.SuperColumn = &SuperColumn{}
  if err := p.SuperColumn.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SuperColumn), err)
  }
  return nil
}

func (p *ColumnOrSuperColumn)  ReadField3(iprot thrift.TProtocol) error {
  p.CounterColumn = &CounterColumn{}
  if err := p.CounterColumn.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CounterColumn), err)
  }
  return nil
}

func (p *ColumnOrSuperColumn)  ReadField4(iprot thrift.TProtocol) error {
  p.CounterSuperColumn = &CounterSuperColumn{}
  if err := p.CounterSuperColumn.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CounterSuperColumn), err)
  }
  return nil
}

func (p *ColumnOrSuperColumn) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ColumnOrSuperColumn"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ColumnOrSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumn() {
    if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column: ", p), err) }
    if err := p.Column.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column: ", p), err) }
  }
  return err
}

func (p *ColumnOrSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuperColumn() {
    if err := oprot.WriteFieldBegin("super_column", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:super_column: ", p), err) }
    if err := p.SuperColumn.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SuperColumn), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:super_column: ", p), err) }
  }
  return err
}

func (p *ColumnOrSuperColumn) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetCounterColumn() {
    if err := oprot.WriteFieldBegin("counter_column", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_column: ", p), err) }
    if err := p.CounterColumn.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CounterColumn), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_column: ", p), err) }
  }
  return err
}

func (p *ColumnOrSuperColumn) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetCounterSuperColumn() {
    if err := oprot.WriteFieldBegin("counter_super_column", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:counter_super_column: ", p), err) }
    if err := p.CounterSuperColumn.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CounterSuperColumn), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:counter_super_column: ", p), err) }
  }
  return err
}

func (p *ColumnOrSuperColumn) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ColumnOrSuperColumn(%+v)", *p)
}

// A specific column was requested that does not exist.
type NotFoundException struct {
}

func NewNotFoundException() *NotFoundException {
  return &NotFoundException{}
}

func (p *NotFoundException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NotFoundException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("NotFoundException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NotFoundException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NotFoundException(%+v)", *p)
}

func (p *NotFoundException) Error() string {
  return p.String()
}

// Invalid request could mean keyspace or column family does not exist, required parameters are missing, or a parameter is malformed.
// why contains an associated error message.
// 
// Attributes:
//  - Why
type InvalidRequestException struct {
  Why string `thrift:"why,1,required" db:"why" json:"why"`
}

func NewInvalidRequestException() *InvalidRequestException {
  return &InvalidRequestException{}
}


func (p *InvalidRequestException) GetWhy() string {
  return p.Why
}
func (p *InvalidRequestException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetWhy bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetWhy = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetWhy{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"));
  }
  return nil
}

func (p *InvalidRequestException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Why = v
}
  return nil
}

func (p *InvalidRequestException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("InvalidRequestException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InvalidRequestException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err) }
  if err := oprot.WriteString(string(p.Why)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err) }
  return err
}

func (p *InvalidRequestException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("InvalidRequestException(%+v)", *p)
}

func (p *InvalidRequestException) Error() string {
  return p.String()
}

// Not all the replicas required could be created and/or read.
type UnavailableException struct {
}

func NewUnavailableException() *UnavailableException {
  return &UnavailableException{}
}

func (p *UnavailableException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UnavailableException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("UnavailableException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UnavailableException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UnavailableException(%+v)", *p)
}

func (p *UnavailableException) Error() string {
  return p.String()
}

// RPC timeout was exceeded.  either a node failed mid-operation, or load was too high, or the requested op was too large.
// 
// Attributes:
//  - AcknowledgedBy: if a write operation was acknowledged by some replicas but not by enough to
// satisfy the required ConsistencyLevel, the number of successful
// replies will be given here. In case of atomic_batch_mutate method this field
// will be set to -1 if the batch was written to the batchlog and to 0 if it wasn't.
//  - AcknowledgedByBatchlog: in case of atomic_batch_mutate method this field tells if the batch
// was written to the batchlog.
//  - PaxosInProgress: for the CAS method, this field tells if we timed out during the paxos
// protocol, as opposed to during the commit of our update
type TimedOutException struct {
  AcknowledgedBy *int32 `thrift:"acknowledged_by,1" db:"acknowledged_by" json:"acknowledged_by,omitempty"`
  AcknowledgedByBatchlog *bool `thrift:"acknowledged_by_batchlog,2" db:"acknowledged_by_batchlog" json:"acknowledged_by_batchlog,omitempty"`
  PaxosInProgress *bool `thrift:"paxos_in_progress,3" db:"paxos_in_progress" json:"paxos_in_progress,omitempty"`
}

func NewTimedOutException() *TimedOutException {
  return &TimedOutException{}
}

var TimedOutException_AcknowledgedBy_DEFAULT int32
func (p *TimedOutException) GetAcknowledgedBy() int32 {
  if !p.IsSetAcknowledgedBy() {
    return TimedOutException_AcknowledgedBy_DEFAULT
  }
return *p.AcknowledgedBy
}
var TimedOutException_AcknowledgedByBatchlog_DEFAULT bool
func (p *TimedOutException) GetAcknowledgedByBatchlog() bool {
  if !p.IsSetAcknowledgedByBatchlog() {
    return TimedOutException_AcknowledgedByBatchlog_DEFAULT
  }
return *p.AcknowledgedByBatchlog
}
var TimedOutException_PaxosInProgress_DEFAULT bool
func (p *TimedOutException) GetPaxosInProgress() bool {
  if !p.IsSetPaxosInProgress() {
    return TimedOutException_PaxosInProgress_DEFAULT
  }
return *p.PaxosInProgress
}
func (p *TimedOutException) IsSetAcknowledgedBy() bool {
  return p.AcknowledgedBy != nil
}

func (p *TimedOutException) IsSetAcknowledgedByBatchlog() bool {
  return p.AcknowledgedByBatchlog != nil
}

func (p *TimedOutException) IsSetPaxosInProgress() bool {
  return p.PaxosInProgress != nil
}

func (p *TimedOutException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TimedOutException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AcknowledgedBy = &v
}
  return nil
}

func (p *TimedOutException)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AcknowledgedByBatchlog = &v
}
  return nil
}

func (p *TimedOutException)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.PaxosInProgress = &v
}
  return nil
}

func (p *TimedOutException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TimedOutException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TimedOutException) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetAcknowledgedBy() {
    if err := oprot.WriteFieldBegin("acknowledged_by", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:acknowledged_by: ", p), err) }
    if err := oprot.WriteI32(int32(*p.AcknowledgedBy)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.acknowledged_by (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:acknowledged_by: ", p), err) }
  }
  return err
}

func (p *TimedOutException) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetAcknowledgedByBatchlog() {
    if err := oprot.WriteFieldBegin("acknowledged_by_batchlog", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:acknowledged_by_batchlog: ", p), err) }
    if err := oprot.WriteBool(bool(*p.AcknowledgedByBatchlog)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.acknowledged_by_batchlog (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:acknowledged_by_batchlog: ", p), err) }
  }
  return err
}

func (p *TimedOutException) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetPaxosInProgress() {
    if err := oprot.WriteFieldBegin("paxos_in_progress", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:paxos_in_progress: ", p), err) }
    if err := oprot.WriteBool(bool(*p.PaxosInProgress)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.paxos_in_progress (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:paxos_in_progress: ", p), err) }
  }
  return err
}

func (p *TimedOutException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TimedOutException(%+v)", *p)
}

func (p *TimedOutException) Error() string {
  return p.String()
}

// invalid authentication request (invalid keyspace, user does not exist, or credentials invalid)
// 
// Attributes:
//  - Why
type AuthenticationException struct {
  Why string `thrift:"why,1,required" db:"why" json:"why"`
}

func NewAuthenticationException() *AuthenticationException {
  return &AuthenticationException{}
}


func (p *AuthenticationException) GetWhy() string {
  return p.Why
}
func (p *AuthenticationException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetWhy bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetWhy = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetWhy{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"));
  }
  return nil
}

func (p *AuthenticationException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Why = v
}
  return nil
}

func (p *AuthenticationException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("AuthenticationException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuthenticationException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err) }
  if err := oprot.WriteString(string(p.Why)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err) }
  return err
}

func (p *AuthenticationException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuthenticationException(%+v)", *p)
}

func (p *AuthenticationException) Error() string {
  return p.String()
}

// invalid authorization request (user does not have access to keyspace)
// 
// Attributes:
//  - Why
type AuthorizationException struct {
  Why string `thrift:"why,1,required" db:"why" json:"why"`
}

func NewAuthorizationException() *AuthorizationException {
  return &AuthorizationException{}
}


func (p *AuthorizationException) GetWhy() string {
  return p.Why
}
func (p *AuthorizationException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetWhy bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetWhy = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetWhy{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"));
  }
  return nil
}

func (p *AuthorizationException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Why = v
}
  return nil
}

func (p *AuthorizationException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("AuthorizationException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuthorizationException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err) }
  if err := oprot.WriteString(string(p.Why)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err) }
  return err
}

func (p *AuthorizationException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuthorizationException(%+v)", *p)
}

func (p *AuthorizationException) Error() string {
  return p.String()
}

// NOTE: This up outdated exception left for backward compatibility reasons,
// no actual schema agreement validation is done starting from Cassandra 1.2
// 
// schemas are not in agreement across all nodes
type SchemaDisagreementException struct {
}

func NewSchemaDisagreementException() *SchemaDisagreementException {
  return &SchemaDisagreementException{}
}

func (p *SchemaDisagreementException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SchemaDisagreementException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("SchemaDisagreementException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SchemaDisagreementException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SchemaDisagreementException(%+v)", *p)
}

func (p *SchemaDisagreementException) Error() string {
  return p.String()
}

// ColumnParent is used when selecting groups of columns from the same ColumnFamily. In directory structure terms, imagine
// ColumnParent as ColumnPath + '/../'.
// 
// See also <a href="cassandra.html#Struct_ColumnPath">ColumnPath</a>
// 
// Attributes:
//  - ColumnFamily
//  - SuperColumn
type ColumnParent struct {
  // unused fields # 1 to 2
  ColumnFamily string `thrift:"column_family,3,required" db:"column_family" json:"column_family"`
  SuperColumn []byte `thrift:"super_column,4" db:"super_column" json:"super_column,omitempty"`
}

func NewColumnParent() *ColumnParent {
  return &ColumnParent{}
}


func (p *ColumnParent) GetColumnFamily() string {
  return p.ColumnFamily
}
var ColumnParent_SuperColumn_DEFAULT []byte

func (p *ColumnParent) GetSuperColumn() []byte {
  return p.SuperColumn
}
func (p *ColumnParent) IsSetSuperColumn() bool {
  return p.SuperColumn != nil
}

func (p *ColumnParent) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnFamily bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnFamily = true
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"));
  }
  return nil
}

func (p *ColumnParent)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ColumnFamily = v
}
  return nil
}

func (p *ColumnParent)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.SuperColumn = v
}
  return nil
}

func (p *ColumnParent) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ColumnParent"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ColumnParent) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_family: ", p), err) }
  if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_family (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_family: ", p), err) }
  return err
}

func (p *ColumnParent) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuperColumn() {
    if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:super_column: ", p), err) }
    if err := oprot.WriteBinary(p.SuperColumn); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.super_column (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:super_column: ", p), err) }
  }
  return err
}

func (p *ColumnParent) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ColumnParent(%+v)", *p)
}

// The ColumnPath is the path to a single column in Cassandra. It might make sense to think of ColumnPath and
// ColumnParent in terms of a directory structure.
// 
// ColumnPath is used to looking up a single column.
// 
// @param column_family. The name of the CF of the column being looked up.
// @param super_column. The super column name.
// @param column. The column name.
// 
// Attributes:
//  - ColumnFamily
//  - SuperColumn
//  - Column
type ColumnPath struct {
  // unused fields # 1 to 2
  ColumnFamily string `thrift:"column_family,3,required" db:"column_family" json:"column_family"`
  SuperColumn []byte `thrift:"super_column,4" db:"super_column" json:"super_column,omitempty"`
  Column []byte `thrift:"column,5" db:"column" json:"column,omitempty"`
}

func NewColumnPath() *ColumnPath {
  return &ColumnPath{}
}


func (p *ColumnPath) GetColumnFamily() string {
  return p.ColumnFamily
}
var ColumnPath_SuperColumn_DEFAULT []byte

func (p *ColumnPath) GetSuperColumn() []byte {
  return p.SuperColumn
}
var ColumnPath_Column_DEFAULT []byte

func (p *ColumnPath) GetColumn() []byte {
  return p.Column
}
func (p *ColumnPath) IsSetSuperColumn() bool {
  return p.SuperColumn != nil
}

func (p *ColumnPath) IsSetColumn() bool {
  return p.Column != nil
}

func (p *ColumnPath) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnFamily bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnFamily = true
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"));
  }
  return nil
}

func (p *ColumnPath)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ColumnFamily = v
}
  return nil
}

func (p *ColumnPath)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.SuperColumn = v
}
  return nil
}

func (p *ColumnPath)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Column = v
}
  return nil
}

func (p *ColumnPath) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ColumnPath"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ColumnPath) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_family: ", p), err) }
  if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_family (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_family: ", p), err) }
  return err
}

func (p *ColumnPath) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuperColumn() {
    if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:super_column: ", p), err) }
    if err := oprot.WriteBinary(p.SuperColumn); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.super_column (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:super_column: ", p), err) }
  }
  return err
}

func (p *ColumnPath) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumn() {
    if err := oprot.WriteFieldBegin("column", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:column: ", p), err) }
    if err := oprot.WriteBinary(p.Column); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.column (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:column: ", p), err) }
  }
  return err
}

func (p *ColumnPath) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ColumnPath(%+v)", *p)
}

// A slice range is a structure that stores basic range, ordering and limit information for a query that will return
// multiple columns. It could be thought of as Cassandra's version of LIMIT and ORDER BY
// 
// @param start. The column name to start the slice with. This attribute is not required, though there is no default value,
//               and can be safely set to '', i.e., an empty byte array, to start with the first column name. Otherwise, it
//               must a valid value under the rules of the Comparator defined for the given ColumnFamily.
// @param finish. The column name to stop the slice at. This attribute is not required, though there is no default value,
//                and can be safely set to an empty byte array to not stop until 'count' results are seen. Otherwise, it
//                must also be a valid value to the ColumnFamily Comparator.
// @param reversed. Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
// @param count. How many columns to return. Similar to LIMIT in SQL. May be arbitrarily large, but Thrift will
//               materialize the whole result into memory before returning it to the client, so be aware that you may
//               be better served by iterating through slices by passing the last value of one call in as the 'start'
//               of the next instead of increasing 'count' arbitrarily large.
// 
// Attributes:
//  - Start
//  - Finish
//  - Reversed
//  - Count
type SliceRange struct {
  Start []byte `thrift:"start,1,required" db:"start" json:"start"`
  Finish []byte `thrift:"finish,2,required" db:"finish" json:"finish"`
  Reversed bool `thrift:"reversed,3,required" db:"reversed" json:"reversed"`
  Count int32 `thrift:"count,4,required" db:"count" json:"count"`
}

func NewSliceRange() *SliceRange {
  return &SliceRange{
Count: 100,
}
}


func (p *SliceRange) GetStart() []byte {
  return p.Start
}

func (p *SliceRange) GetFinish() []byte {
  return p.Finish
}

func (p *SliceRange) GetReversed() bool {
  return p.Reversed
}

func (p *SliceRange) GetCount() int32 {
  return p.Count
}
func (p *SliceRange) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStart bool = false;
  var issetFinish bool = false;
  var issetReversed bool = false;
  var issetCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStart = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetFinish = true
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetReversed = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCount = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStart{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Start is not set"));
  }
  if !issetFinish{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Finish is not set"));
  }
  if !issetReversed{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Reversed is not set"));
  }
  if !issetCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"));
  }
  return nil
}

func (p *SliceRange)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Start = v
}
  return nil
}

func (p *SliceRange)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Finish = v
}
  return nil
}

func (p *SliceRange)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Reversed = v
}
  return nil
}

func (p *SliceRange)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *SliceRange) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("SliceRange"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SliceRange) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err) }
  if err := oprot.WriteBinary(p.Start); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err) }
  return err
}

func (p *SliceRange) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finish: ", p), err) }
  if err := oprot.WriteBinary(p.Finish); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.finish (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finish: ", p), err) }
  return err
}

func (p *SliceRange) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reversed: ", p), err) }
  if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reversed (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reversed: ", p), err) }
  return err
}

func (p *SliceRange) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:count: ", p), err) }
  if err := oprot.WriteI32(int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:count: ", p), err) }
  return err
}

func (p *SliceRange) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SliceRange(%+v)", *p)
}

// A SlicePredicate is similar to a mathematic predicate (see http://en.wikipedia.org/wiki/Predicate_(mathematical_logic)),
// which is described as "a property that the elements of a set have in common."
// 
// SlicePredicate's in Cassandra are described with either a list of column_names or a SliceRange.  If column_names is
// specified, slice_range is ignored.
// 
// @param column_name. A list of column names to retrieve. This can be used similar to Memcached's "multi-get" feature
//                     to fetch N known column names. For instance, if you know you wish to fetch columns 'Joe', 'Jack',
//                     and 'Jim' you can pass those column names as a list to fetch all three at once.
// @param slice_range. A SliceRange describing how to range, order, and/or limit the slice.
// 
// Attributes:
//  - ColumnNames
//  - SliceRange
type SlicePredicate struct {
  ColumnNames [][]byte `thrift:"column_names,1" db:"column_names" json:"column_names,omitempty"`
  SliceRange *SliceRange `thrift:"slice_range,2" db:"slice_range" json:"slice_range,omitempty"`
}

func NewSlicePredicate() *SlicePredicate {
  return &SlicePredicate{}
}

var SlicePredicate_ColumnNames_DEFAULT [][]byte

func (p *SlicePredicate) GetColumnNames() [][]byte {
  return p.ColumnNames
}
var SlicePredicate_SliceRange_DEFAULT *SliceRange
func (p *SlicePredicate) GetSliceRange() *SliceRange {
  if !p.IsSetSliceRange() {
    return SlicePredicate_SliceRange_DEFAULT
  }
return p.SliceRange
}
func (p *SlicePredicate) IsSetColumnNames() bool {
  return p.ColumnNames != nil
}

func (p *SlicePredicate) IsSetSliceRange() bool {
  return p.SliceRange != nil
}

func (p *SlicePredicate) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SlicePredicate)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.ColumnNames =  tSlice
  for i := 0; i < size; i ++ {
var _elem2 []byte
    if v, err := iprot.ReadBinary(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem2 = v
}
    p.ColumnNames = append(p.ColumnNames, _elem2)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SlicePredicate)  ReadField2(iprot thrift.TProtocol) error {
  p.SliceRange = &SliceRange{
  Count: 100,
}
  if err := p.SliceRange.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SliceRange), err)
  }
  return nil
}

func (p *SlicePredicate) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("SlicePredicate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SlicePredicate) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnNames() {
    if err := oprot.WriteFieldBegin("column_names", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_names: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.ColumnNames)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ColumnNames {
      if err := oprot.WriteBinary(v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_names: ", p), err) }
  }
  return err
}

func (p *SlicePredicate) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSliceRange() {
    if err := oprot.WriteFieldBegin("slice_range", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:slice_range: ", p), err) }
    if err := p.SliceRange.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SliceRange), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:slice_range: ", p), err) }
  }
  return err
}

func (p *SlicePredicate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SlicePredicate(%+v)", *p)
}

// Attributes:
//  - ColumnName
//  - Op
//  - Value
type IndexExpression struct {
  ColumnName []byte `thrift:"column_name,1,required" db:"column_name" json:"column_name"`
  Op IndexOperator `thrift:"op,2,required" db:"op" json:"op"`
  Value []byte `thrift:"value,3,required" db:"value" json:"value"`
}

func NewIndexExpression() *IndexExpression {
  return &IndexExpression{}
}


func (p *IndexExpression) GetColumnName() []byte {
  return p.ColumnName
}

func (p *IndexExpression) GetOp() IndexOperator {
  return p.Op
}

func (p *IndexExpression) GetValue() []byte {
  return p.Value
}
func (p *IndexExpression) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnName bool = false;
  var issetOp bool = false;
  var issetValue bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnName = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetOp = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValue = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnName is not set"));
  }
  if !issetOp{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Op is not set"));
  }
  if !issetValue{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"));
  }
  return nil
}

func (p *IndexExpression)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ColumnName = v
}
  return nil
}

func (p *IndexExpression)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := IndexOperator(v)
  p.Op = temp
}
  return nil
}

func (p *IndexExpression)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *IndexExpression) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("IndexExpression"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IndexExpression) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_name: ", p), err) }
  if err := oprot.WriteBinary(p.ColumnName); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_name: ", p), err) }
  return err
}

func (p *IndexExpression) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *IndexExpression) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:value: ", p), err) }
  if err := oprot.WriteBinary(p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:value: ", p), err) }
  return err
}

func (p *IndexExpression) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IndexExpression(%+v)", *p)
}

// @deprecated use a KeyRange with row_filter in get_range_slices instead
// 
// Attributes:
//  - Expressions
//  - StartKey
//  - Count
type IndexClause struct {
  Expressions []*IndexExpression `thrift:"expressions,1,required" db:"expressions" json:"expressions"`
  StartKey []byte `thrift:"start_key,2,required" db:"start_key" json:"start_key"`
  Count int32 `thrift:"count,3,required" db:"count" json:"count"`
}

func NewIndexClause() *IndexClause {
  return &IndexClause{
Count: 100,
}
}


func (p *IndexClause) GetExpressions() []*IndexExpression {
  return p.Expressions
}

func (p *IndexClause) GetStartKey() []byte {
  return p.StartKey
}

func (p *IndexClause) GetCount() int32 {
  return p.Count
}
func (p *IndexClause) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetExpressions bool = false;
  var issetStartKey bool = false;
  var issetCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetExpressions = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartKey = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCount = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetExpressions{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Expressions is not set"));
  }
  if !issetStartKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartKey is not set"));
  }
  if !issetCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"));
  }
  return nil
}

func (p *IndexClause)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*IndexExpression, 0, size)
  p.Expressions =  tSlice
  for i := 0; i < size; i ++ {
    _elem3 := &IndexExpression{}
    if err := _elem3.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem3), err)
    }
    p.Expressions = append(p.Expressions, _elem3)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IndexClause)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StartKey = v
}
  return nil
}

func (p *IndexClause)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *IndexClause) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("IndexClause"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IndexClause) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("expressions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:expressions: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expressions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Expressions {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:expressions: ", p), err) }
  return err
}

func (p *IndexClause) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_key: ", p), err) }
  if err := oprot.WriteBinary(p.StartKey); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_key (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_key: ", p), err) }
  return err
}

func (p *IndexClause) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:count: ", p), err) }
  if err := oprot.WriteI32(int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:count: ", p), err) }
  return err
}

func (p *IndexClause) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IndexClause(%+v)", *p)
}

// The semantics of start keys and tokens are slightly different.
// Keys are start-inclusive; tokens are start-exclusive.  Token
// ranges may also wrap -- that is, the end token may be less
// than the start one.  Thus, a range from keyX to keyX is a
// one-element range, but a range from tokenY to tokenY is the
// full ring.
// 
// Attributes:
//  - StartKey
//  - EndKey
//  - StartToken
//  - EndToken
//  - RowFilter
//  - Count
type KeyRange struct {
  StartKey []byte `thrift:"start_key,1" db:"start_key" json:"start_key,omitempty"`
  EndKey []byte `thrift:"end_key,2" db:"end_key" json:"end_key,omitempty"`
  StartToken *string `thrift:"start_token,3" db:"start_token" json:"start_token,omitempty"`
  EndToken *string `thrift:"end_token,4" db:"end_token" json:"end_token,omitempty"`
  Count int32 `thrift:"count,5,required" db:"count" json:"count"`
  RowFilter []*IndexExpression `thrift:"row_filter,6" db:"row_filter" json:"row_filter,omitempty"`
}

func NewKeyRange() *KeyRange {
  return &KeyRange{
Count: 100,
}
}

var KeyRange_StartKey_DEFAULT []byte

func (p *KeyRange) GetStartKey() []byte {
  return p.StartKey
}
var KeyRange_EndKey_DEFAULT []byte

func (p *KeyRange) GetEndKey() []byte {
  return p.EndKey
}
var KeyRange_StartToken_DEFAULT string
func (p *KeyRange) GetStartToken() string {
  if !p.IsSetStartToken() {
    return KeyRange_StartToken_DEFAULT
  }
return *p.StartToken
}
var KeyRange_EndToken_DEFAULT string
func (p *KeyRange) GetEndToken() string {
  if !p.IsSetEndToken() {
    return KeyRange_EndToken_DEFAULT
  }
return *p.EndToken
}
var KeyRange_RowFilter_DEFAULT []*IndexExpression

func (p *KeyRange) GetRowFilter() []*IndexExpression {
  return p.RowFilter
}

func (p *KeyRange) GetCount() int32 {
  return p.Count
}
func (p *KeyRange) IsSetStartKey() bool {
  return p.StartKey != nil
}

func (p *KeyRange) IsSetEndKey() bool {
  return p.EndKey != nil
}

func (p *KeyRange) IsSetStartToken() bool {
  return p.StartToken != nil
}

func (p *KeyRange) IsSetEndToken() bool {
  return p.EndToken != nil
}

func (p *KeyRange) IsSetRowFilter() bool {
  return p.RowFilter != nil
}

func (p *KeyRange) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCount = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"));
  }
  return nil
}

func (p *KeyRange)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartKey = v
}
  return nil
}

func (p *KeyRange)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EndKey = v
}
  return nil
}

func (p *KeyRange)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.StartToken = &v
}
  return nil
}

func (p *KeyRange)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.EndToken = &v
}
  return nil
}

func (p *KeyRange)  ReadField6(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*IndexExpression, 0, size)
  p.RowFilter =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &IndexExpression{}
    if err := _elem4.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.RowFilter = append(p.RowFilter, _elem4)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KeyRange)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *KeyRange) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("KeyRange"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KeyRange) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetStartKey() {
    if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_key: ", p), err) }
    if err := oprot.WriteBinary(p.StartKey); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.start_key (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_key: ", p), err) }
  }
  return err
}

func (p *KeyRange) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetEndKey() {
    if err := oprot.WriteFieldBegin("end_key", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_key: ", p), err) }
    if err := oprot.WriteBinary(p.EndKey); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.end_key (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_key: ", p), err) }
  }
  return err
}

func (p *KeyRange) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetStartToken() {
    if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:start_token: ", p), err) }
    if err := oprot.WriteString(string(*p.StartToken)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.start_token (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:start_token: ", p), err) }
  }
  return err
}

func (p *KeyRange) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetEndToken() {
    if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:end_token: ", p), err) }
    if err := oprot.WriteString(string(*p.EndToken)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.end_token (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:end_token: ", p), err) }
  }
  return err
}

func (p *KeyRange) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:count: ", p), err) }
  if err := oprot.WriteI32(int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:count: ", p), err) }
  return err
}

func (p *KeyRange) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetRowFilter() {
    if err := oprot.WriteFieldBegin("row_filter", thrift.LIST, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:row_filter: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowFilter)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RowFilter {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:row_filter: ", p), err) }
  }
  return err
}

func (p *KeyRange) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KeyRange(%+v)", *p)
}

// A KeySlice is key followed by the data it maps to. A collection of KeySlice is returned by the get_range_slice operation.
// 
// @param key. a row key
// @param columns. List of data represented by the key. Typically, the list is pared down to only the columns specified by
//                 a SlicePredicate.
// 
// Attributes:
//  - Key
//  - Columns
type KeySlice struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  Columns []*ColumnOrSuperColumn `thrift:"columns,2,required" db:"columns" json:"columns"`
}

func NewKeySlice() *KeySlice {
  return &KeySlice{}
}


func (p *KeySlice) GetKey() []byte {
  return p.Key
}

func (p *KeySlice) GetColumns() []*ColumnOrSuperColumn {
  return p.Columns
}
func (p *KeySlice) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumns = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *KeySlice)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *KeySlice)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ColumnOrSuperColumn, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem5 := &ColumnOrSuperColumn{}
    if err := _elem5.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem5), err)
    }
    p.Columns = append(p.Columns, _elem5)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KeySlice) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("KeySlice"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KeySlice) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *KeySlice) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *KeySlice) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KeySlice(%+v)", *p)
}

// Attributes:
//  - Key
//  - Count
type KeyCount struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  Count int32 `thrift:"count,2,required" db:"count" json:"count"`
}

func NewKeyCount() *KeyCount {
  return &KeyCount{}
}


func (p *KeyCount) GetKey() []byte {
  return p.Key
}

func (p *KeyCount) GetCount() int32 {
  return p.Count
}
func (p *KeyCount) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCount = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"));
  }
  return nil
}

func (p *KeyCount)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *KeyCount)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *KeyCount) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("KeyCount"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KeyCount) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *KeyCount) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:count: ", p), err) }
  if err := oprot.WriteI32(int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:count: ", p), err) }
  return err
}

func (p *KeyCount) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KeyCount(%+v)", *p)
}

// Note that the timestamp is only optional in case of counter deletion.
// 
// Attributes:
//  - Timestamp
//  - SuperColumn
//  - Predicate
type Deletion struct {
  Timestamp *int64 `thrift:"timestamp,1" db:"timestamp" json:"timestamp,omitempty"`
  SuperColumn []byte `thrift:"super_column,2" db:"super_column" json:"super_column,omitempty"`
  Predicate *SlicePredicate `thrift:"predicate,3" db:"predicate" json:"predicate,omitempty"`
}

func NewDeletion() *Deletion {
  return &Deletion{}
}

var Deletion_Timestamp_DEFAULT int64
func (p *Deletion) GetTimestamp() int64 {
  if !p.IsSetTimestamp() {
    return Deletion_Timestamp_DEFAULT
  }
return *p.Timestamp
}
var Deletion_SuperColumn_DEFAULT []byte

func (p *Deletion) GetSuperColumn() []byte {
  return p.SuperColumn
}
var Deletion_Predicate_DEFAULT *SlicePredicate
func (p *Deletion) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return Deletion_Predicate_DEFAULT
  }
return p.Predicate
}
func (p *Deletion) IsSetTimestamp() bool {
  return p.Timestamp != nil
}

func (p *Deletion) IsSetSuperColumn() bool {
  return p.SuperColumn != nil
}

func (p *Deletion) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *Deletion) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Deletion)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Timestamp = &v
}
  return nil
}

func (p *Deletion)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.SuperColumn = v
}
  return nil
}

func (p *Deletion)  ReadField3(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *Deletion) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Deletion"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Deletion) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetTimestamp() {
    if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timestamp: ", p), err) }
    if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timestamp (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timestamp: ", p), err) }
  }
  return err
}

func (p *Deletion) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuperColumn() {
    if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:super_column: ", p), err) }
    if err := oprot.WriteBinary(p.SuperColumn); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.super_column (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:super_column: ", p), err) }
  }
  return err
}

func (p *Deletion) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetPredicate() {
    if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err) }
    if err := p.Predicate.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err) }
  }
  return err
}

func (p *Deletion) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Deletion(%+v)", *p)
}

// A Mutation is either an insert (represented by filling column_or_supercolumn) or a deletion (represented by filling the deletion attribute).
// @param column_or_supercolumn. An insert to a column or supercolumn (possibly counter column or supercolumn)
// @param deletion. A deletion of a column or supercolumn
// 
// Attributes:
//  - ColumnOrSupercolumn
//  - Deletion
type Mutation struct {
  ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"column_or_supercolumn,1" db:"column_or_supercolumn" json:"column_or_supercolumn,omitempty"`
  Deletion *Deletion `thrift:"deletion,2" db:"deletion" json:"deletion,omitempty"`
}

func NewMutation() *Mutation {
  return &Mutation{}
}

var Mutation_ColumnOrSupercolumn_DEFAULT *ColumnOrSuperColumn
func (p *Mutation) GetColumnOrSupercolumn() *ColumnOrSuperColumn {
  if !p.IsSetColumnOrSupercolumn() {
    return Mutation_ColumnOrSupercolumn_DEFAULT
  }
return p.ColumnOrSupercolumn
}
var Mutation_Deletion_DEFAULT *Deletion
func (p *Mutation) GetDeletion() *Deletion {
  if !p.IsSetDeletion() {
    return Mutation_Deletion_DEFAULT
  }
return p.Deletion
}
func (p *Mutation) IsSetColumnOrSupercolumn() bool {
  return p.ColumnOrSupercolumn != nil
}

func (p *Mutation) IsSetDeletion() bool {
  return p.Deletion != nil
}

func (p *Mutation) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Mutation)  ReadField1(iprot thrift.TProtocol) error {
  p.ColumnOrSupercolumn = &ColumnOrSuperColumn{}
  if err := p.ColumnOrSupercolumn.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnOrSupercolumn), err)
  }
  return nil
}

func (p *Mutation)  ReadField2(iprot thrift.TProtocol) error {
  p.Deletion = &Deletion{}
  if err := p.Deletion.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Deletion), err)
  }
  return nil
}

func (p *Mutation) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Mutation"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Mutation) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnOrSupercolumn() {
    if err := oprot.WriteFieldBegin("column_or_supercolumn", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_or_supercolumn: ", p), err) }
    if err := p.ColumnOrSupercolumn.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnOrSupercolumn), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_or_supercolumn: ", p), err) }
  }
  return err
}

func (p *Mutation) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetDeletion() {
    if err := oprot.WriteFieldBegin("deletion", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:deletion: ", p), err) }
    if err := p.Deletion.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Deletion), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:deletion: ", p), err) }
  }
  return err
}

func (p *Mutation) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Mutation(%+v)", *p)
}

// Attributes:
//  - Host
//  - Datacenter
//  - Rack
type EndpointDetails struct {
  Host string `thrift:"host,1" db:"host" json:"host"`
  Datacenter string `thrift:"datacenter,2" db:"datacenter" json:"datacenter"`
  Rack *string `thrift:"rack,3" db:"rack" json:"rack,omitempty"`
}

func NewEndpointDetails() *EndpointDetails {
  return &EndpointDetails{}
}


func (p *EndpointDetails) GetHost() string {
  return p.Host
}

func (p *EndpointDetails) GetDatacenter() string {
  return p.Datacenter
}
var EndpointDetails_Rack_DEFAULT string
func (p *EndpointDetails) GetRack() string {
  if !p.IsSetRack() {
    return EndpointDetails_Rack_DEFAULT
  }
return *p.Rack
}
func (p *EndpointDetails) IsSetRack() bool {
  return p.Rack != nil
}

func (p *EndpointDetails) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *EndpointDetails)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *EndpointDetails)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Datacenter = v
}
  return nil
}

func (p *EndpointDetails)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Rack = &v
}
  return nil
}

func (p *EndpointDetails) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("EndpointDetails"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EndpointDetails) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err) }
  if err := oprot.WriteString(string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err) }
  return err
}

func (p *EndpointDetails) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("datacenter", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:datacenter: ", p), err) }
  if err := oprot.WriteString(string(p.Datacenter)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.datacenter (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:datacenter: ", p), err) }
  return err
}

func (p *EndpointDetails) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetRack() {
    if err := oprot.WriteFieldBegin("rack", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rack: ", p), err) }
    if err := oprot.WriteString(string(*p.Rack)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.rack (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rack: ", p), err) }
  }
  return err
}

func (p *EndpointDetails) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EndpointDetails(%+v)", *p)
}

// Attributes:
//  - Success
//  - CurrentValues
type CASResult_ struct {
  Success bool `thrift:"success,1,required" db:"success" json:"success"`
  CurrentValues []*Column `thrift:"current_values,2" db:"current_values" json:"current_values,omitempty"`
}

func NewCASResult_() *CASResult_ {
  return &CASResult_{}
}


func (p *CASResult_) GetSuccess() bool {
  return p.Success
}
var CASResult__CurrentValues_DEFAULT []*Column

func (p *CASResult_) GetCurrentValues() []*Column {
  return p.CurrentValues
}
func (p *CASResult_) IsSetCurrentValues() bool {
  return p.CurrentValues != nil
}

func (p *CASResult_) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetSuccess bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetSuccess = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetSuccess{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Success is not set"));
  }
  return nil
}

func (p *CASResult_)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *CASResult_)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Column, 0, size)
  p.CurrentValues =  tSlice
  for i := 0; i < size; i ++ {
    _elem6 := &Column{}
    if err := _elem6.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem6), err)
    }
    p.CurrentValues = append(p.CurrentValues, _elem6)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CASResult_) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CASResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CASResult_) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("success", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:success: ", p), err) }
  if err := oprot.WriteBool(bool(p.Success)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.success (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:success: ", p), err) }
  return err
}

func (p *CASResult_) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetCurrentValues() {
    if err := oprot.WriteFieldBegin("current_values", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:current_values: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CurrentValues)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.CurrentValues {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:current_values: ", p), err) }
  }
  return err
}

func (p *CASResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CASResult_(%+v)", *p)
}

// A TokenRange describes part of the Cassandra ring, it is a mapping from a range to
// endpoints responsible for that range.
// @param start_token The first token in the range
// @param end_token The last token in the range
// @param endpoints The endpoints responsible for the range (listed by their configured listen_address)
// @param rpc_endpoints The endpoints responsible for the range (listed by their configured rpc_address)
// 
// Attributes:
//  - StartToken
//  - EndToken
//  - Endpoints
//  - RPCEndpoints
//  - EndpointDetails
type TokenRange struct {
  StartToken string `thrift:"start_token,1,required" db:"start_token" json:"start_token"`
  EndToken string `thrift:"end_token,2,required" db:"end_token" json:"end_token"`
  Endpoints []string `thrift:"endpoints,3,required" db:"endpoints" json:"endpoints"`
  RPCEndpoints []string `thrift:"rpc_endpoints,4" db:"rpc_endpoints" json:"rpc_endpoints,omitempty"`
  EndpointDetails []*EndpointDetails `thrift:"endpoint_details,5" db:"endpoint_details" json:"endpoint_details,omitempty"`
}

func NewTokenRange() *TokenRange {
  return &TokenRange{}
}


func (p *TokenRange) GetStartToken() string {
  return p.StartToken
}

func (p *TokenRange) GetEndToken() string {
  return p.EndToken
}

func (p *TokenRange) GetEndpoints() []string {
  return p.Endpoints
}
var TokenRange_RPCEndpoints_DEFAULT []string

func (p *TokenRange) GetRPCEndpoints() []string {
  return p.RPCEndpoints
}
var TokenRange_EndpointDetails_DEFAULT []*EndpointDetails

func (p *TokenRange) GetEndpointDetails() []*EndpointDetails {
  return p.EndpointDetails
}
func (p *TokenRange) IsSetRPCEndpoints() bool {
  return p.RPCEndpoints != nil
}

func (p *TokenRange) IsSetEndpointDetails() bool {
  return p.EndpointDetails != nil
}

func (p *TokenRange) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartToken bool = false;
  var issetEndToken bool = false;
  var issetEndpoints bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartToken = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetEndToken = true
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetEndpoints = true
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"));
  }
  if !issetEndToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"));
  }
  if !issetEndpoints{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Endpoints is not set"));
  }
  return nil
}

func (p *TokenRange)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartToken = v
}
  return nil
}

func (p *TokenRange)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EndToken = v
}
  return nil
}

func (p *TokenRange)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Endpoints =  tSlice
  for i := 0; i < size; i ++ {
var _elem7 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem7 = v
}
    p.Endpoints = append(p.Endpoints, _elem7)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenRange)  ReadField4(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.RPCEndpoints =  tSlice
  for i := 0; i < size; i ++ {
var _elem8 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem8 = v
}
    p.RPCEndpoints = append(p.RPCEndpoints, _elem8)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenRange)  ReadField5(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*EndpointDetails, 0, size)
  p.EndpointDetails =  tSlice
  for i := 0; i < size; i ++ {
    _elem9 := &EndpointDetails{}
    if err := _elem9.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
    }
    p.EndpointDetails = append(p.EndpointDetails, _elem9)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *TokenRange) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TokenRange"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TokenRange) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_token: ", p), err) }
  if err := oprot.WriteString(string(p.StartToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_token (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_token: ", p), err) }
  return err
}

func (p *TokenRange) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_token: ", p), err) }
  if err := oprot.WriteString(string(p.EndToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.end_token (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_token: ", p), err) }
  return err
}

func (p *TokenRange) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("endpoints", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:endpoints: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Endpoints)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Endpoints {
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:endpoints: ", p), err) }
  return err
}

func (p *TokenRange) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetRPCEndpoints() {
    if err := oprot.WriteFieldBegin("rpc_endpoints", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rpc_endpoints: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.RPCEndpoints)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RPCEndpoints {
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rpc_endpoints: ", p), err) }
  }
  return err
}

func (p *TokenRange) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetEndpointDetails() {
    if err := oprot.WriteFieldBegin("endpoint_details", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:endpoint_details: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.EndpointDetails)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.EndpointDetails {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:endpoint_details: ", p), err) }
  }
  return err
}

func (p *TokenRange) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TokenRange(%+v)", *p)
}

// Authentication requests can contain any data, dependent on the IAuthenticator used
// 
// Attributes:
//  - Credentials
type AuthenticationRequest struct {
  Credentials map[string]string `thrift:"credentials,1,required" db:"credentials" json:"credentials"`
}

func NewAuthenticationRequest() *AuthenticationRequest {
  return &AuthenticationRequest{}
}


func (p *AuthenticationRequest) GetCredentials() map[string]string {
  return p.Credentials
}
func (p *AuthenticationRequest) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCredentials bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCredentials = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCredentials{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Credentials is not set"));
  }
  return nil
}

func (p *AuthenticationRequest)  ReadField1(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Credentials =  tMap
  for i := 0; i < size; i ++ {
var _key10 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key10 = v
}
var _val11 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val11 = v
}
    p.Credentials[_key10] = _val11
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *AuthenticationRequest) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("AuthenticationRequest"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuthenticationRequest) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("credentials", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:credentials: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Credentials)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Credentials {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:credentials: ", p), err) }
  return err
}

func (p *AuthenticationRequest) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuthenticationRequest(%+v)", *p)
}

// Attributes:
//  - Name
//  - ValidationClass
//  - IndexType
//  - IndexName
//  - IndexOptions
type ColumnDef struct {
  Name []byte `thrift:"name,1,required" db:"name" json:"name"`
  ValidationClass string `thrift:"validation_class,2,required" db:"validation_class" json:"validation_class"`
  IndexType *IndexType `thrift:"index_type,3" db:"index_type" json:"index_type,omitempty"`
  IndexName *string `thrift:"index_name,4" db:"index_name" json:"index_name,omitempty"`
  IndexOptions map[string]string `thrift:"index_options,5" db:"index_options" json:"index_options,omitempty"`
}

func NewColumnDef() *ColumnDef {
  return &ColumnDef{}
}


func (p *ColumnDef) GetName() []byte {
  return p.Name
}

func (p *ColumnDef) GetValidationClass() string {
  return p.ValidationClass
}
var ColumnDef_IndexType_DEFAULT IndexType
func (p *ColumnDef) GetIndexType() IndexType {
  if !p.IsSetIndexType() {
    return ColumnDef_IndexType_DEFAULT
  }
return *p.IndexType
}
var ColumnDef_IndexName_DEFAULT string
func (p *ColumnDef) GetIndexName() string {
  if !p.IsSetIndexName() {
    return ColumnDef_IndexName_DEFAULT
  }
return *p.IndexName
}
var ColumnDef_IndexOptions_DEFAULT map[string]string

func (p *ColumnDef) GetIndexOptions() map[string]string {
  return p.IndexOptions
}
func (p *ColumnDef) IsSetIndexType() bool {
  return p.IndexType != nil
}

func (p *ColumnDef) IsSetIndexName() bool {
  return p.IndexName != nil
}

func (p *ColumnDef) IsSetIndexOptions() bool {
  return p.IndexOptions != nil
}

func (p *ColumnDef) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetValidationClass bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValidationClass = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetValidationClass{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ValidationClass is not set"));
  }
  return nil
}

func (p *ColumnDef)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ColumnDef)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ValidationClass = v
}
  return nil
}

func (p *ColumnDef)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := IndexType(v)
  p.IndexType = &temp
}
  return nil
}

func (p *ColumnDef)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.IndexName = &v
}
  return nil
}

func (p *ColumnDef)  ReadField5(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.IndexOptions =  tMap
  for i := 0; i < size; i ++ {
var _key12 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key12 = v
}
var _val13 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val13 = v
}
    p.IndexOptions[_key12] = _val13
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ColumnDef) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ColumnDef"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ColumnDef) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ColumnDef) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("validation_class", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:validation_class: ", p), err) }
  if err := oprot.WriteString(string(p.ValidationClass)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.validation_class (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:validation_class: ", p), err) }
  return err
}

func (p *ColumnDef) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetIndexType() {
    if err := oprot.WriteFieldBegin("index_type", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:index_type: ", p), err) }
    if err := oprot.WriteI32(int32(*p.IndexType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.index_type (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:index_type: ", p), err) }
  }
  return err
}

func (p *ColumnDef) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetIndexName() {
    if err := oprot.WriteFieldBegin("index_name", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:index_name: ", p), err) }
    if err := oprot.WriteString(string(*p.IndexName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.index_name (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:index_name: ", p), err) }
  }
  return err
}

func (p *ColumnDef) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetIndexOptions() {
    if err := oprot.WriteFieldBegin("index_options", thrift.MAP, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:index_options: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.IndexOptions)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.IndexOptions {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:index_options: ", p), err) }
  }
  return err
}

func (p *ColumnDef) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ColumnDef(%+v)", *p)
}

// Describes a trigger.
// `options` should include at least 'class' param.
// Other options are not supported yet.
// 
// Attributes:
//  - Name
//  - Options
type TriggerDef struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
  Options map[string]string `thrift:"options,2,required" db:"options" json:"options"`
}

func NewTriggerDef() *TriggerDef {
  return &TriggerDef{}
}


func (p *TriggerDef) GetName() string {
  return p.Name
}

func (p *TriggerDef) GetOptions() map[string]string {
  return p.Options
}
func (p *TriggerDef) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetOptions bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetOptions = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetOptions{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Options is not set"));
  }
  return nil
}

func (p *TriggerDef)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *TriggerDef)  ReadField2(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Options =  tMap
  for i := 0; i < size; i ++ {
var _key14 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key14 = v
}
var _val15 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val15 = v
}
    p.Options[_key14] = _val15
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TriggerDef) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("TriggerDef"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TriggerDef) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *TriggerDef) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("options", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:options: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Options)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Options {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:options: ", p), err) }
  return err
}

func (p *TriggerDef) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TriggerDef(%+v)", *p)
}

// Attributes:
//  - Keyspace
//  - Name
//  - ColumnType
//  - ComparatorType
//  - SubcomparatorType
//  - Comment
//  - ReadRepairChance
//  - ColumnMetadata
//  - GcGraceSeconds
//  - DefaultValidationClass
//  - ID
//  - MinCompactionThreshold
//  - MaxCompactionThreshold
//  - KeyValidationClass
//  - KeyAlias
//  - CompactionStrategy
//  - CompactionStrategyOptions
//  - CompressionOptions
//  - BloomFilterFpChance
//  - Caching
//  - DclocalReadRepairChance
//  - MemtableFlushPeriodInMs
//  - DefaultTimeToLive
//  - SpeculativeRetry
//  - Triggers
//  - CellsPerRowToCache
//  - MinIndexInterval
//  - MaxIndexInterval
//  - RowCacheSize: @deprecated
//  - KeyCacheSize: @deprecated
//  - RowCacheSavePeriodInSeconds: @deprecated
//  - KeyCacheSavePeriodInSeconds: @deprecated
//  - MemtableFlushAfterMins: @deprecated
//  - MemtableThroughputInMb: @deprecated
//  - MemtableOperationsInMillions: @deprecated
//  - ReplicateOnWrite: @deprecated
//  - MergeShardsChance: @deprecated
//  - RowCacheProvider: @deprecated
//  - RowCacheKeysToSave: @deprecated
//  - PopulateIoCacheOnFlush: @deprecated
//  - IndexInterval: @deprecated
type CfDef struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
  Name string `thrift:"name,2,required" db:"name" json:"name"`
  ColumnType string `thrift:"column_type,3" db:"column_type" json:"column_type,omitempty"`
  // unused field # 4
  ComparatorType string `thrift:"comparator_type,5" db:"comparator_type" json:"comparator_type,omitempty"`
  SubcomparatorType *string `thrift:"subcomparator_type,6" db:"subcomparator_type" json:"subcomparator_type,omitempty"`
  // unused field # 7
  Comment *string `thrift:"comment,8" db:"comment" json:"comment,omitempty"`
  RowCacheSize *float64 `thrift:"row_cache_size,9" db:"row_cache_size" json:"row_cache_size,omitempty"`
  // unused field # 10
  KeyCacheSize *float64 `thrift:"key_cache_size,11" db:"key_cache_size" json:"key_cache_size,omitempty"`
  ReadRepairChance *float64 `thrift:"read_repair_chance,12" db:"read_repair_chance" json:"read_repair_chance,omitempty"`
  ColumnMetadata []*ColumnDef `thrift:"column_metadata,13" db:"column_metadata" json:"column_metadata,omitempty"`
  GcGraceSeconds *int32 `thrift:"gc_grace_seconds,14" db:"gc_grace_seconds" json:"gc_grace_seconds,omitempty"`
  DefaultValidationClass *string `thrift:"default_validation_class,15" db:"default_validation_class" json:"default_validation_class,omitempty"`
  ID *int32 `thrift:"id,16" db:"id" json:"id,omitempty"`
  MinCompactionThreshold *int32 `thrift:"min_compaction_threshold,17" db:"min_compaction_threshold" json:"min_compaction_threshold,omitempty"`
  MaxCompactionThreshold *int32 `thrift:"max_compaction_threshold,18" db:"max_compaction_threshold" json:"max_compaction_threshold,omitempty"`
  RowCacheSavePeriodInSeconds *int32 `thrift:"row_cache_save_period_in_seconds,19" db:"row_cache_save_period_in_seconds" json:"row_cache_save_period_in_seconds,omitempty"`
  KeyCacheSavePeriodInSeconds *int32 `thrift:"key_cache_save_period_in_seconds,20" db:"key_cache_save_period_in_seconds" json:"key_cache_save_period_in_seconds,omitempty"`
  MemtableFlushAfterMins *int32 `thrift:"memtable_flush_after_mins,21" db:"memtable_flush_after_mins" json:"memtable_flush_after_mins,omitempty"`
  MemtableThroughputInMb *int32 `thrift:"memtable_throughput_in_mb,22" db:"memtable_throughput_in_mb" json:"memtable_throughput_in_mb,omitempty"`
  MemtableOperationsInMillions *float64 `thrift:"memtable_operations_in_millions,23" db:"memtable_operations_in_millions" json:"memtable_operations_in_millions,omitempty"`
  ReplicateOnWrite *bool `thrift:"replicate_on_write,24" db:"replicate_on_write" json:"replicate_on_write,omitempty"`
  MergeShardsChance *float64 `thrift:"merge_shards_chance,25" db:"merge_shards_chance" json:"merge_shards_chance,omitempty"`
  KeyValidationClass *string `thrift:"key_validation_class,26" db:"key_validation_class" json:"key_validation_class,omitempty"`
  RowCacheProvider *string `thrift:"row_cache_provider,27" db:"row_cache_provider" json:"row_cache_provider,omitempty"`
  KeyAlias []byte `thrift:"key_alias,28" db:"key_alias" json:"key_alias,omitempty"`
  CompactionStrategy *string `thrift:"compaction_strategy,29" db:"compaction_strategy" json:"compaction_strategy,omitempty"`
  CompactionStrategyOptions map[string]string `thrift:"compaction_strategy_options,30" db:"compaction_strategy_options" json:"compaction_strategy_options,omitempty"`
  RowCacheKeysToSave *int32 `thrift:"row_cache_keys_to_save,31" db:"row_cache_keys_to_save" json:"row_cache_keys_to_save,omitempty"`
  CompressionOptions map[string]string `thrift:"compression_options,32" db:"compression_options" json:"compression_options,omitempty"`
  BloomFilterFpChance *float64 `thrift:"bloom_filter_fp_chance,33" db:"bloom_filter_fp_chance" json:"bloom_filter_fp_chance,omitempty"`
  Caching string `thrift:"caching,34" db:"caching" json:"caching,omitempty"`
  // unused fields # 35 to 36
  DclocalReadRepairChance float64 `thrift:"dclocal_read_repair_chance,37" db:"dclocal_read_repair_chance" json:"dclocal_read_repair_chance,omitempty"`
  PopulateIoCacheOnFlush *bool `thrift:"populate_io_cache_on_flush,38" db:"populate_io_cache_on_flush" json:"populate_io_cache_on_flush,omitempty"`
  MemtableFlushPeriodInMs *int32 `thrift:"memtable_flush_period_in_ms,39" db:"memtable_flush_period_in_ms" json:"memtable_flush_period_in_ms,omitempty"`
  DefaultTimeToLive *int32 `thrift:"default_time_to_live,40" db:"default_time_to_live" json:"default_time_to_live,omitempty"`
  IndexInterval *int32 `thrift:"index_interval,41" db:"index_interval" json:"index_interval,omitempty"`
  SpeculativeRetry string `thrift:"speculative_retry,42" db:"speculative_retry" json:"speculative_retry,omitempty"`
  Triggers []*TriggerDef `thrift:"triggers,43" db:"triggers" json:"triggers,omitempty"`
  CellsPerRowToCache string `thrift:"cells_per_row_to_cache,44" db:"cells_per_row_to_cache" json:"cells_per_row_to_cache,omitempty"`
  MinIndexInterval *int32 `thrift:"min_index_interval,45" db:"min_index_interval" json:"min_index_interval,omitempty"`
  MaxIndexInterval *int32 `thrift:"max_index_interval,46" db:"max_index_interval" json:"max_index_interval,omitempty"`
}

func NewCfDef() *CfDef {
  return &CfDef{
ColumnType: "Standard",

ComparatorType: "BytesType",

Caching: "keys_only",

SpeculativeRetry: "NONE",

CellsPerRowToCache: "100",
}
}


func (p *CfDef) GetKeyspace() string {
  return p.Keyspace
}

func (p *CfDef) GetName() string {
  return p.Name
}
var CfDef_ColumnType_DEFAULT string = "Standard"

func (p *CfDef) GetColumnType() string {
  return p.ColumnType
}
var CfDef_ComparatorType_DEFAULT string = "BytesType"

func (p *CfDef) GetComparatorType() string {
  return p.ComparatorType
}
var CfDef_SubcomparatorType_DEFAULT string
func (p *CfDef) GetSubcomparatorType() string {
  if !p.IsSetSubcomparatorType() {
    return CfDef_SubcomparatorType_DEFAULT
  }
return *p.SubcomparatorType
}
var CfDef_Comment_DEFAULT string
func (p *CfDef) GetComment() string {
  if !p.IsSetComment() {
    return CfDef_Comment_DEFAULT
  }
return *p.Comment
}
var CfDef_ReadRepairChance_DEFAULT float64
func (p *CfDef) GetReadRepairChance() float64 {
  if !p.IsSetReadRepairChance() {
    return CfDef_ReadRepairChance_DEFAULT
  }
return *p.ReadRepairChance
}
var CfDef_ColumnMetadata_DEFAULT []*ColumnDef

func (p *CfDef) GetColumnMetadata() []*ColumnDef {
  return p.ColumnMetadata
}
var CfDef_GcGraceSeconds_DEFAULT int32
func (p *CfDef) GetGcGraceSeconds() int32 {
  if !p.IsSetGcGraceSeconds() {
    return CfDef_GcGraceSeconds_DEFAULT
  }
return *p.GcGraceSeconds
}
var CfDef_DefaultValidationClass_DEFAULT string
func (p *CfDef) GetDefaultValidationClass() string {
  if !p.IsSetDefaultValidationClass() {
    return CfDef_DefaultValidationClass_DEFAULT
  }
return *p.DefaultValidationClass
}
var CfDef_ID_DEFAULT int32
func (p *CfDef) GetID() int32 {
  if !p.IsSetID() {
    return CfDef_ID_DEFAULT
  }
return *p.ID
}
var CfDef_MinCompactionThreshold_DEFAULT int32
func (p *CfDef) GetMinCompactionThreshold() int32 {
  if !p.IsSetMinCompactionThreshold() {
    return CfDef_MinCompactionThreshold_DEFAULT
  }
return *p.MinCompactionThreshold
}
var CfDef_MaxCompactionThreshold_DEFAULT int32
func (p *CfDef) GetMaxCompactionThreshold() int32 {
  if !p.IsSetMaxCompactionThreshold() {
    return CfDef_MaxCompactionThreshold_DEFAULT
  }
return *p.MaxCompactionThreshold
}
var CfDef_KeyValidationClass_DEFAULT string
func (p *CfDef) GetKeyValidationClass() string {
  if !p.IsSetKeyValidationClass() {
    return CfDef_KeyValidationClass_DEFAULT
  }
return *p.KeyValidationClass
}
var CfDef_KeyAlias_DEFAULT []byte

func (p *CfDef) GetKeyAlias() []byte {
  return p.KeyAlias
}
var CfDef_CompactionStrategy_DEFAULT string
func (p *CfDef) GetCompactionStrategy() string {
  if !p.IsSetCompactionStrategy() {
    return CfDef_CompactionStrategy_DEFAULT
  }
return *p.CompactionStrategy
}
var CfDef_CompactionStrategyOptions_DEFAULT map[string]string

func (p *CfDef) GetCompactionStrategyOptions() map[string]string {
  return p.CompactionStrategyOptions
}
var CfDef_CompressionOptions_DEFAULT map[string]string

func (p *CfDef) GetCompressionOptions() map[string]string {
  return p.CompressionOptions
}
var CfDef_BloomFilterFpChance_DEFAULT float64
func (p *CfDef) GetBloomFilterFpChance() float64 {
  if !p.IsSetBloomFilterFpChance() {
    return CfDef_BloomFilterFpChance_DEFAULT
  }
return *p.BloomFilterFpChance
}
var CfDef_Caching_DEFAULT string = "keys_only"

func (p *CfDef) GetCaching() string {
  return p.Caching
}
var CfDef_DclocalReadRepairChance_DEFAULT float64 = 0

func (p *CfDef) GetDclocalReadRepairChance() float64 {
  return p.DclocalReadRepairChance
}
var CfDef_MemtableFlushPeriodInMs_DEFAULT int32
func (p *CfDef) GetMemtableFlushPeriodInMs() int32 {
  if !p.IsSetMemtableFlushPeriodInMs() {
    return CfDef_MemtableFlushPeriodInMs_DEFAULT
  }
return *p.MemtableFlushPeriodInMs
}
var CfDef_DefaultTimeToLive_DEFAULT int32
func (p *CfDef) GetDefaultTimeToLive() int32 {
  if !p.IsSetDefaultTimeToLive() {
    return CfDef_DefaultTimeToLive_DEFAULT
  }
return *p.DefaultTimeToLive
}
var CfDef_SpeculativeRetry_DEFAULT string = "NONE"

func (p *CfDef) GetSpeculativeRetry() string {
  return p.SpeculativeRetry
}
var CfDef_Triggers_DEFAULT []*TriggerDef

func (p *CfDef) GetTriggers() []*TriggerDef {
  return p.Triggers
}
var CfDef_CellsPerRowToCache_DEFAULT string = "100"

func (p *CfDef) GetCellsPerRowToCache() string {
  return p.CellsPerRowToCache
}
var CfDef_MinIndexInterval_DEFAULT int32
func (p *CfDef) GetMinIndexInterval() int32 {
  if !p.IsSetMinIndexInterval() {
    return CfDef_MinIndexInterval_DEFAULT
  }
return *p.MinIndexInterval
}
var CfDef_MaxIndexInterval_DEFAULT int32
func (p *CfDef) GetMaxIndexInterval() int32 {
  if !p.IsSetMaxIndexInterval() {
    return CfDef_MaxIndexInterval_DEFAULT
  }
return *p.MaxIndexInterval
}
var CfDef_RowCacheSize_DEFAULT float64
func (p *CfDef) GetRowCacheSize() float64 {
  if !p.IsSetRowCacheSize() {
    return CfDef_RowCacheSize_DEFAULT
  }
return *p.RowCacheSize
}
var CfDef_KeyCacheSize_DEFAULT float64
func (p *CfDef) GetKeyCacheSize() float64 {
  if !p.IsSetKeyCacheSize() {
    return CfDef_KeyCacheSize_DEFAULT
  }
return *p.KeyCacheSize
}
var CfDef_RowCacheSavePeriodInSeconds_DEFAULT int32
func (p *CfDef) GetRowCacheSavePeriodInSeconds() int32 {
  if !p.IsSetRowCacheSavePeriodInSeconds() {
    return CfDef_RowCacheSavePeriodInSeconds_DEFAULT
  }
return *p.RowCacheSavePeriodInSeconds
}
var CfDef_KeyCacheSavePeriodInSeconds_DEFAULT int32
func (p *CfDef) GetKeyCacheSavePeriodInSeconds() int32 {
  if !p.IsSetKeyCacheSavePeriodInSeconds() {
    return CfDef_KeyCacheSavePeriodInSeconds_DEFAULT
  }
return *p.KeyCacheSavePeriodInSeconds
}
var CfDef_MemtableFlushAfterMins_DEFAULT int32
func (p *CfDef) GetMemtableFlushAfterMins() int32 {
  if !p.IsSetMemtableFlushAfterMins() {
    return CfDef_MemtableFlushAfterMins_DEFAULT
  }
return *p.MemtableFlushAfterMins
}
var CfDef_MemtableThroughputInMb_DEFAULT int32
func (p *CfDef) GetMemtableThroughputInMb() int32 {
  if !p.IsSetMemtableThroughputInMb() {
    return CfDef_MemtableThroughputInMb_DEFAULT
  }
return *p.MemtableThroughputInMb
}
var CfDef_MemtableOperationsInMillions_DEFAULT float64
func (p *CfDef) GetMemtableOperationsInMillions() float64 {
  if !p.IsSetMemtableOperationsInMillions() {
    return CfDef_MemtableOperationsInMillions_DEFAULT
  }
return *p.MemtableOperationsInMillions
}
var CfDef_ReplicateOnWrite_DEFAULT bool
func (p *CfDef) GetReplicateOnWrite() bool {
  if !p.IsSetReplicateOnWrite() {
    return CfDef_ReplicateOnWrite_DEFAULT
  }
return *p.ReplicateOnWrite
}
var CfDef_MergeShardsChance_DEFAULT float64
func (p *CfDef) GetMergeShardsChance() float64 {
  if !p.IsSetMergeShardsChance() {
    return CfDef_MergeShardsChance_DEFAULT
  }
return *p.MergeShardsChance
}
var CfDef_RowCacheProvider_DEFAULT string
func (p *CfDef) GetRowCacheProvider() string {
  if !p.IsSetRowCacheProvider() {
    return CfDef_RowCacheProvider_DEFAULT
  }
return *p.RowCacheProvider
}
var CfDef_RowCacheKeysToSave_DEFAULT int32
func (p *CfDef) GetRowCacheKeysToSave() int32 {
  if !p.IsSetRowCacheKeysToSave() {
    return CfDef_RowCacheKeysToSave_DEFAULT
  }
return *p.RowCacheKeysToSave
}
var CfDef_PopulateIoCacheOnFlush_DEFAULT bool
func (p *CfDef) GetPopulateIoCacheOnFlush() bool {
  if !p.IsSetPopulateIoCacheOnFlush() {
    return CfDef_PopulateIoCacheOnFlush_DEFAULT
  }
return *p.PopulateIoCacheOnFlush
}
var CfDef_IndexInterval_DEFAULT int32
func (p *CfDef) GetIndexInterval() int32 {
  if !p.IsSetIndexInterval() {
    return CfDef_IndexInterval_DEFAULT
  }
return *p.IndexInterval
}
func (p *CfDef) IsSetColumnType() bool {
  return p.ColumnType != CfDef_ColumnType_DEFAULT
}

func (p *CfDef) IsSetComparatorType() bool {
  return p.ComparatorType != CfDef_ComparatorType_DEFAULT
}

func (p *CfDef) IsSetSubcomparatorType() bool {
  return p.SubcomparatorType != nil
}

func (p *CfDef) IsSetComment() bool {
  return p.Comment != nil
}

func (p *CfDef) IsSetReadRepairChance() bool {
  return p.ReadRepairChance != nil
}

func (p *CfDef) IsSetColumnMetadata() bool {
  return p.ColumnMetadata != nil
}

func (p *CfDef) IsSetGcGraceSeconds() bool {
  return p.GcGraceSeconds != nil
}

func (p *CfDef) IsSetDefaultValidationClass() bool {
  return p.DefaultValidationClass != nil
}

func (p *CfDef) IsSetID() bool {
  return p.ID != nil
}

func (p *CfDef) IsSetMinCompactionThreshold() bool {
  return p.MinCompactionThreshold != nil
}

func (p *CfDef) IsSetMaxCompactionThreshold() bool {
  return p.MaxCompactionThreshold != nil
}

func (p *CfDef) IsSetKeyValidationClass() bool {
  return p.KeyValidationClass != nil
}

func (p *CfDef) IsSetKeyAlias() bool {
  return p.KeyAlias != nil
}

func (p *CfDef) IsSetCompactionStrategy() bool {
  return p.CompactionStrategy != nil
}

func (p *CfDef) IsSetCompactionStrategyOptions() bool {
  return p.CompactionStrategyOptions != nil
}

func (p *CfDef) IsSetCompressionOptions() bool {
  return p.CompressionOptions != nil
}

func (p *CfDef) IsSetBloomFilterFpChance() bool {
  return p.BloomFilterFpChance != nil
}

func (p *CfDef) IsSetCaching() bool {
  return p.Caching != CfDef_Caching_DEFAULT
}

func (p *CfDef) IsSetDclocalReadRepairChance() bool {
  return p.DclocalReadRepairChance != CfDef_DclocalReadRepairChance_DEFAULT
}

func (p *CfDef) IsSetMemtableFlushPeriodInMs() bool {
  return p.MemtableFlushPeriodInMs != nil
}

func (p *CfDef) IsSetDefaultTimeToLive() bool {
  return p.DefaultTimeToLive != nil
}

func (p *CfDef) IsSetSpeculativeRetry() bool {
  return p.SpeculativeRetry != CfDef_SpeculativeRetry_DEFAULT
}

func (p *CfDef) IsSetTriggers() bool {
  return p.Triggers != nil
}

func (p *CfDef) IsSetCellsPerRowToCache() bool {
  return p.CellsPerRowToCache != CfDef_CellsPerRowToCache_DEFAULT
}

func (p *CfDef) IsSetMinIndexInterval() bool {
  return p.MinIndexInterval != nil
}

func (p *CfDef) IsSetMaxIndexInterval() bool {
  return p.MaxIndexInterval != nil
}

func (p *CfDef) IsSetRowCacheSize() bool {
  return p.RowCacheSize != nil
}

func (p *CfDef) IsSetKeyCacheSize() bool {
  return p.KeyCacheSize != nil
}

func (p *CfDef) IsSetRowCacheSavePeriodInSeconds() bool {
  return p.RowCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetKeyCacheSavePeriodInSeconds() bool {
  return p.KeyCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetMemtableFlushAfterMins() bool {
  return p.MemtableFlushAfterMins != nil
}

func (p *CfDef) IsSetMemtableThroughputInMb() bool {
  return p.MemtableThroughputInMb != nil
}

func (p *CfDef) IsSetMemtableOperationsInMillions() bool {
  return p.MemtableOperationsInMillions != nil
}

func (p *CfDef) IsSetReplicateOnWrite() bool {
  return p.ReplicateOnWrite != nil
}

func (p *CfDef) IsSetMergeShardsChance() bool {
  return p.MergeShardsChance != nil
}

func (p *CfDef) IsSetRowCacheProvider() bool {
  return p.RowCacheProvider != nil
}

func (p *CfDef) IsSetRowCacheKeysToSave() bool {
  return p.RowCacheKeysToSave != nil
}

func (p *CfDef) IsSetPopulateIoCacheOnFlush() bool {
  return p.PopulateIoCacheOnFlush != nil
}

func (p *CfDef) IsSetIndexInterval() bool {
  return p.IndexInterval != nil
}

func (p *CfDef) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;
  var issetName bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField12(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField13(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField14(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField15(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField16(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField17(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField18(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 26:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField26(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 28:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField28(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 29:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField29(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 30:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField30(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 32:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField32(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 33:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField33(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 34:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField34(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 37:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField37(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 39:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField39(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 40:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField40(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 42:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField42(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 43:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField43(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 44:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField44(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 45:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField45(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 46:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField46(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField9(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField11(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 19:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField19(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField20(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 21:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField21(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 22:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField22(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 23:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField23(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 24:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField24(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 25:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField25(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 27:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField27(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 31:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField31(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 38:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField38(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 41:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField41(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  return nil
}

func (p *CfDef)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CfDef)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *CfDef)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ColumnType = v
}
  return nil
}

func (p *CfDef)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.ComparatorType = v
}
  return nil
}

func (p *CfDef)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.SubcomparatorType = &v
}
  return nil
}

func (p *CfDef)  ReadField8(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.Comment = &v
}
  return nil
}

func (p *CfDef)  ReadField12(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.ReadRepairChance = &v
}
  return nil
}

func (p *CfDef)  ReadField13(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ColumnDef, 0, size)
  p.ColumnMetadata =  tSlice
  for i := 0; i < size; i ++ {
    _elem16 := &ColumnDef{}
    if err := _elem16.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
    }
    p.ColumnMetadata = append(p.ColumnMetadata, _elem16)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CfDef)  ReadField14(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.GcGraceSeconds = &v
}
  return nil
}

func (p *CfDef)  ReadField15(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  p.DefaultValidationClass = &v
}
  return nil
}

func (p *CfDef)  ReadField16(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  p.ID = &v
}
  return nil
}

func (p *CfDef)  ReadField17(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 17: ", err)
} else {
  p.MinCompactionThreshold = &v
}
  return nil
}

func (p *CfDef)  ReadField18(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 18: ", err)
} else {
  p.MaxCompactionThreshold = &v
}
  return nil
}

func (p *CfDef)  ReadField26(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 26: ", err)
} else {
  p.KeyValidationClass = &v
}
  return nil
}

func (p *CfDef)  ReadField28(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 28: ", err)
} else {
  p.KeyAlias = v
}
  return nil
}

func (p *CfDef)  ReadField29(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 29: ", err)
} else {
  p.CompactionStrategy = &v
}
  return nil
}

func (p *CfDef)  ReadField30(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.CompactionStrategyOptions =  tMap
  for i := 0; i < size; i ++ {
var _key17 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key17 = v
}
var _val18 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val18 = v
}
    p.CompactionStrategyOptions[_key17] = _val18
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CfDef)  ReadField32(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.CompressionOptions =  tMap
  for i := 0; i < size; i ++ {
var _key19 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key19 = v
}
var _val20 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val20 = v
}
    p.CompressionOptions[_key19] = _val20
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CfDef)  ReadField33(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 33: ", err)
} else {
  p.BloomFilterFpChance = &v
}
  return nil
}

func (p *CfDef)  ReadField34(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 34: ", err)
} else {
  p.Caching = v
}
  return nil
}

func (p *CfDef)  ReadField37(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 37: ", err)
} else {
  p.DclocalReadRepairChance = v
}
  return nil
}

func (p *CfDef)  ReadField39(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 39: ", err)
} else {
  p.MemtableFlushPeriodInMs = &v
}
  return nil
}

func (p *CfDef)  ReadField40(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 40: ", err)
} else {
  p.DefaultTimeToLive = &v
}
  return nil
}

func (p *CfDef)  ReadField42(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 42: ", err)
} else {
  p.SpeculativeRetry = v
}
  return nil
}

func (p *CfDef)  ReadField43(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TriggerDef, 0, size)
  p.Triggers =  tSlice
  for i := 0; i < size; i ++ {
    _elem21 := &TriggerDef{}
    if err := _elem21.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem21), err)
    }
    p.Triggers = append(p.Triggers, _elem21)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CfDef)  ReadField44(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 44: ", err)
} else {
  p.CellsPerRowToCache = v
}
  return nil
}

func (p *CfDef)  ReadField45(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 45: ", err)
} else {
  p.MinIndexInterval = &v
}
  return nil
}

func (p *CfDef)  ReadField46(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 46: ", err)
} else {
  p.MaxIndexInterval = &v
}
  return nil
}

func (p *CfDef)  ReadField9(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.RowCacheSize = &v
}
  return nil
}

func (p *CfDef)  ReadField11(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.KeyCacheSize = &v
}
  return nil
}

func (p *CfDef)  ReadField19(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 19: ", err)
} else {
  p.RowCacheSavePeriodInSeconds = &v
}
  return nil
}

func (p *CfDef)  ReadField20(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 20: ", err)
} else {
  p.KeyCacheSavePeriodInSeconds = &v
}
  return nil
}

func (p *CfDef)  ReadField21(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 21: ", err)
} else {
  p.MemtableFlushAfterMins = &v
}
  return nil
}

func (p *CfDef)  ReadField22(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 22: ", err)
} else {
  p.MemtableThroughputInMb = &v
}
  return nil
}

func (p *CfDef)  ReadField23(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 23: ", err)
} else {
  p.MemtableOperationsInMillions = &v
}
  return nil
}

func (p *CfDef)  ReadField24(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 24: ", err)
} else {
  p.ReplicateOnWrite = &v
}
  return nil
}

func (p *CfDef)  ReadField25(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(); err != nil {
  return thrift.PrependError("error reading field 25: ", err)
} else {
  p.MergeShardsChance = &v
}
  return nil
}

func (p *CfDef)  ReadField27(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 27: ", err)
} else {
  p.RowCacheProvider = &v
}
  return nil
}

func (p *CfDef)  ReadField31(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 31: ", err)
} else {
  p.RowCacheKeysToSave = &v
}
  return nil
}

func (p *CfDef)  ReadField38(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 38: ", err)
} else {
  p.PopulateIoCacheOnFlush = &v
}
  return nil
}

func (p *CfDef)  ReadField41(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 41: ", err)
} else {
  p.IndexInterval = &v
}
  return nil
}

func (p *CfDef) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CfDef"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
    if err := p.writeField8(oprot); err != nil { return err }
    if err := p.writeField9(oprot); err != nil { return err }
    if err := p.writeField11(oprot); err != nil { return err }
    if err := p.writeField12(oprot); err != nil { return err }
    if err := p.writeField13(oprot); err != nil { return err }
    if err := p.writeField14(oprot); err != nil { return err }
    if err := p.writeField15(oprot); err != nil { return err }
    if err := p.writeField16(oprot); err != nil { return err }
    if err := p.writeField17(oprot); err != nil { return err }
    if err := p.writeField18(oprot); err != nil { return err }
    if err := p.writeField19(oprot); err != nil { return err }
    if err := p.writeField20(oprot); err != nil { return err }
    if err := p.writeField21(oprot); err != nil { return err }
    if err := p.writeField22(oprot); err != nil { return err }
    if err := p.writeField23(oprot); err != nil { return err }
    if err := p.writeField24(oprot); err != nil { return err }
    if err := p.writeField25(oprot); err != nil { return err }
    if err := p.writeField26(oprot); err != nil { return err }
    if err := p.writeField27(oprot); err != nil { return err }
    if err := p.writeField28(oprot); err != nil { return err }
    if err := p.writeField29(oprot); err != nil { return err }
    if err := p.writeField30(oprot); err != nil { return err }
    if err := p.writeField31(oprot); err != nil { return err }
    if err := p.writeField32(oprot); err != nil { return err }
    if err := p.writeField33(oprot); err != nil { return err }
    if err := p.writeField34(oprot); err != nil { return err }
    if err := p.writeField37(oprot); err != nil { return err }
    if err := p.writeField38(oprot); err != nil { return err }
    if err := p.writeField39(oprot); err != nil { return err }
    if err := p.writeField40(oprot); err != nil { return err }
    if err := p.writeField41(oprot); err != nil { return err }
    if err := p.writeField42(oprot); err != nil { return err }
    if err := p.writeField43(oprot); err != nil { return err }
    if err := p.writeField44(oprot); err != nil { return err }
    if err := p.writeField45(oprot); err != nil { return err }
    if err := p.writeField46(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CfDef) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CfDef) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:name: ", p), err) }
  return err
}

func (p *CfDef) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnType() {
    if err := oprot.WriteFieldBegin("column_type", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_type: ", p), err) }
    if err := oprot.WriteString(string(p.ColumnType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.column_type (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_type: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetComparatorType() {
    if err := oprot.WriteFieldBegin("comparator_type", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:comparator_type: ", p), err) }
    if err := oprot.WriteString(string(p.ComparatorType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.comparator_type (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:comparator_type: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetSubcomparatorType() {
    if err := oprot.WriteFieldBegin("subcomparator_type", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:subcomparator_type: ", p), err) }
    if err := oprot.WriteString(string(*p.SubcomparatorType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.subcomparator_type (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:subcomparator_type: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField8(oprot thrift.TProtocol) (err error) {
  if p.IsSetComment() {
    if err := oprot.WriteFieldBegin("comment", thrift.STRING, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:comment: ", p), err) }
    if err := oprot.WriteString(string(*p.Comment)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.comment (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:comment: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField9(oprot thrift.TProtocol) (err error) {
  if p.IsSetRowCacheSize() {
    if err := oprot.WriteFieldBegin("row_cache_size", thrift.DOUBLE, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:row_cache_size: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.RowCacheSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.row_cache_size (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:row_cache_size: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField11(oprot thrift.TProtocol) (err error) {
  if p.IsSetKeyCacheSize() {
    if err := oprot.WriteFieldBegin("key_cache_size", thrift.DOUBLE, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:key_cache_size: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.KeyCacheSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key_cache_size (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:key_cache_size: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField12(oprot thrift.TProtocol) (err error) {
  if p.IsSetReadRepairChance() {
    if err := oprot.WriteFieldBegin("read_repair_chance", thrift.DOUBLE, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:read_repair_chance: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.ReadRepairChance)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.read_repair_chance (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:read_repair_chance: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField13(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnMetadata() {
    if err := oprot.WriteFieldBegin("column_metadata", thrift.LIST, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:column_metadata: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnMetadata)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ColumnMetadata {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:column_metadata: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField14(oprot thrift.TProtocol) (err error) {
  if p.IsSetGcGraceSeconds() {
    if err := oprot.WriteFieldBegin("gc_grace_seconds", thrift.I32, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:gc_grace_seconds: ", p), err) }
    if err := oprot.WriteI32(int32(*p.GcGraceSeconds)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.gc_grace_seconds (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:gc_grace_seconds: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField15(oprot thrift.TProtocol) (err error) {
  if p.IsSetDefaultValidationClass() {
    if err := oprot.WriteFieldBegin("default_validation_class", thrift.STRING, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:default_validation_class: ", p), err) }
    if err := oprot.WriteString(string(*p.DefaultValidationClass)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.default_validation_class (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:default_validation_class: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField16(oprot thrift.TProtocol) (err error) {
  if p.IsSetID() {
    if err := oprot.WriteFieldBegin("id", thrift.I32, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:id: ", p), err) }
    if err := oprot.WriteI32(int32(*p.ID)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.id (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:id: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField17(oprot thrift.TProtocol) (err error) {
  if p.IsSetMinCompactionThreshold() {
    if err := oprot.WriteFieldBegin("min_compaction_threshold", thrift.I32, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:min_compaction_threshold: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MinCompactionThreshold)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.min_compaction_threshold (17) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:min_compaction_threshold: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField18(oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxCompactionThreshold() {
    if err := oprot.WriteFieldBegin("max_compaction_threshold", thrift.I32, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:max_compaction_threshold: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MaxCompactionThreshold)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.max_compaction_threshold (18) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:max_compaction_threshold: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField19(oprot thrift.TProtocol) (err error) {
  if p.IsSetRowCacheSavePeriodInSeconds() {
    if err := oprot.WriteFieldBegin("row_cache_save_period_in_seconds", thrift.I32, 19); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 19:row_cache_save_period_in_seconds: ", p), err) }
    if err := oprot.WriteI32(int32(*p.RowCacheSavePeriodInSeconds)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.row_cache_save_period_in_seconds (19) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 19:row_cache_save_period_in_seconds: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField20(oprot thrift.TProtocol) (err error) {
  if p.IsSetKeyCacheSavePeriodInSeconds() {
    if err := oprot.WriteFieldBegin("key_cache_save_period_in_seconds", thrift.I32, 20); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:key_cache_save_period_in_seconds: ", p), err) }
    if err := oprot.WriteI32(int32(*p.KeyCacheSavePeriodInSeconds)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key_cache_save_period_in_seconds (20) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 20:key_cache_save_period_in_seconds: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField21(oprot thrift.TProtocol) (err error) {
  if p.IsSetMemtableFlushAfterMins() {
    if err := oprot.WriteFieldBegin("memtable_flush_after_mins", thrift.I32, 21); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 21:memtable_flush_after_mins: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MemtableFlushAfterMins)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.memtable_flush_after_mins (21) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 21:memtable_flush_after_mins: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField22(oprot thrift.TProtocol) (err error) {
  if p.IsSetMemtableThroughputInMb() {
    if err := oprot.WriteFieldBegin("memtable_throughput_in_mb", thrift.I32, 22); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 22:memtable_throughput_in_mb: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MemtableThroughputInMb)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.memtable_throughput_in_mb (22) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 22:memtable_throughput_in_mb: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField23(oprot thrift.TProtocol) (err error) {
  if p.IsSetMemtableOperationsInMillions() {
    if err := oprot.WriteFieldBegin("memtable_operations_in_millions", thrift.DOUBLE, 23); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 23:memtable_operations_in_millions: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.MemtableOperationsInMillions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.memtable_operations_in_millions (23) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 23:memtable_operations_in_millions: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField24(oprot thrift.TProtocol) (err error) {
  if p.IsSetReplicateOnWrite() {
    if err := oprot.WriteFieldBegin("replicate_on_write", thrift.BOOL, 24); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 24:replicate_on_write: ", p), err) }
    if err := oprot.WriteBool(bool(*p.ReplicateOnWrite)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.replicate_on_write (24) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 24:replicate_on_write: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField25(oprot thrift.TProtocol) (err error) {
  if p.IsSetMergeShardsChance() {
    if err := oprot.WriteFieldBegin("merge_shards_chance", thrift.DOUBLE, 25); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 25:merge_shards_chance: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.MergeShardsChance)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.merge_shards_chance (25) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 25:merge_shards_chance: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField26(oprot thrift.TProtocol) (err error) {
  if p.IsSetKeyValidationClass() {
    if err := oprot.WriteFieldBegin("key_validation_class", thrift.STRING, 26); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 26:key_validation_class: ", p), err) }
    if err := oprot.WriteString(string(*p.KeyValidationClass)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key_validation_class (26) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 26:key_validation_class: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField27(oprot thrift.TProtocol) (err error) {
  if p.IsSetRowCacheProvider() {
    if err := oprot.WriteFieldBegin("row_cache_provider", thrift.STRING, 27); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 27:row_cache_provider: ", p), err) }
    if err := oprot.WriteString(string(*p.RowCacheProvider)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.row_cache_provider (27) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 27:row_cache_provider: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField28(oprot thrift.TProtocol) (err error) {
  if p.IsSetKeyAlias() {
    if err := oprot.WriteFieldBegin("key_alias", thrift.STRING, 28); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 28:key_alias: ", p), err) }
    if err := oprot.WriteBinary(p.KeyAlias); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key_alias (28) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 28:key_alias: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField29(oprot thrift.TProtocol) (err error) {
  if p.IsSetCompactionStrategy() {
    if err := oprot.WriteFieldBegin("compaction_strategy", thrift.STRING, 29); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 29:compaction_strategy: ", p), err) }
    if err := oprot.WriteString(string(*p.CompactionStrategy)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.compaction_strategy (29) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 29:compaction_strategy: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField30(oprot thrift.TProtocol) (err error) {
  if p.IsSetCompactionStrategyOptions() {
    if err := oprot.WriteFieldBegin("compaction_strategy_options", thrift.MAP, 30); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 30:compaction_strategy_options: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompactionStrategyOptions)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.CompactionStrategyOptions {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 30:compaction_strategy_options: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField31(oprot thrift.TProtocol) (err error) {
  if p.IsSetRowCacheKeysToSave() {
    if err := oprot.WriteFieldBegin("row_cache_keys_to_save", thrift.I32, 31); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 31:row_cache_keys_to_save: ", p), err) }
    if err := oprot.WriteI32(int32(*p.RowCacheKeysToSave)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.row_cache_keys_to_save (31) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 31:row_cache_keys_to_save: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField32(oprot thrift.TProtocol) (err error) {
  if p.IsSetCompressionOptions() {
    if err := oprot.WriteFieldBegin("compression_options", thrift.MAP, 32); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 32:compression_options: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompressionOptions)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.CompressionOptions {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 32:compression_options: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField33(oprot thrift.TProtocol) (err error) {
  if p.IsSetBloomFilterFpChance() {
    if err := oprot.WriteFieldBegin("bloom_filter_fp_chance", thrift.DOUBLE, 33); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 33:bloom_filter_fp_chance: ", p), err) }
    if err := oprot.WriteDouble(float64(*p.BloomFilterFpChance)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.bloom_filter_fp_chance (33) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 33:bloom_filter_fp_chance: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField34(oprot thrift.TProtocol) (err error) {
  if p.IsSetCaching() {
    if err := oprot.WriteFieldBegin("caching", thrift.STRING, 34); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 34:caching: ", p), err) }
    if err := oprot.WriteString(string(p.Caching)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.caching (34) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 34:caching: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField37(oprot thrift.TProtocol) (err error) {
  if p.IsSetDclocalReadRepairChance() {
    if err := oprot.WriteFieldBegin("dclocal_read_repair_chance", thrift.DOUBLE, 37); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 37:dclocal_read_repair_chance: ", p), err) }
    if err := oprot.WriteDouble(float64(p.DclocalReadRepairChance)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.dclocal_read_repair_chance (37) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 37:dclocal_read_repair_chance: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField38(oprot thrift.TProtocol) (err error) {
  if p.IsSetPopulateIoCacheOnFlush() {
    if err := oprot.WriteFieldBegin("populate_io_cache_on_flush", thrift.BOOL, 38); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 38:populate_io_cache_on_flush: ", p), err) }
    if err := oprot.WriteBool(bool(*p.PopulateIoCacheOnFlush)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.populate_io_cache_on_flush (38) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 38:populate_io_cache_on_flush: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField39(oprot thrift.TProtocol) (err error) {
  if p.IsSetMemtableFlushPeriodInMs() {
    if err := oprot.WriteFieldBegin("memtable_flush_period_in_ms", thrift.I32, 39); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 39:memtable_flush_period_in_ms: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MemtableFlushPeriodInMs)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.memtable_flush_period_in_ms (39) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 39:memtable_flush_period_in_ms: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField40(oprot thrift.TProtocol) (err error) {
  if p.IsSetDefaultTimeToLive() {
    if err := oprot.WriteFieldBegin("default_time_to_live", thrift.I32, 40); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 40:default_time_to_live: ", p), err) }
    if err := oprot.WriteI32(int32(*p.DefaultTimeToLive)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.default_time_to_live (40) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 40:default_time_to_live: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField41(oprot thrift.TProtocol) (err error) {
  if p.IsSetIndexInterval() {
    if err := oprot.WriteFieldBegin("index_interval", thrift.I32, 41); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 41:index_interval: ", p), err) }
    if err := oprot.WriteI32(int32(*p.IndexInterval)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.index_interval (41) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 41:index_interval: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField42(oprot thrift.TProtocol) (err error) {
  if p.IsSetSpeculativeRetry() {
    if err := oprot.WriteFieldBegin("speculative_retry", thrift.STRING, 42); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 42:speculative_retry: ", p), err) }
    if err := oprot.WriteString(string(p.SpeculativeRetry)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.speculative_retry (42) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 42:speculative_retry: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField43(oprot thrift.TProtocol) (err error) {
  if p.IsSetTriggers() {
    if err := oprot.WriteFieldBegin("triggers", thrift.LIST, 43); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 43:triggers: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Triggers)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Triggers {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 43:triggers: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField44(oprot thrift.TProtocol) (err error) {
  if p.IsSetCellsPerRowToCache() {
    if err := oprot.WriteFieldBegin("cells_per_row_to_cache", thrift.STRING, 44); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 44:cells_per_row_to_cache: ", p), err) }
    if err := oprot.WriteString(string(p.CellsPerRowToCache)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cells_per_row_to_cache (44) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 44:cells_per_row_to_cache: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField45(oprot thrift.TProtocol) (err error) {
  if p.IsSetMinIndexInterval() {
    if err := oprot.WriteFieldBegin("min_index_interval", thrift.I32, 45); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 45:min_index_interval: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MinIndexInterval)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.min_index_interval (45) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 45:min_index_interval: ", p), err) }
  }
  return err
}

func (p *CfDef) writeField46(oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxIndexInterval() {
    if err := oprot.WriteFieldBegin("max_index_interval", thrift.I32, 46); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 46:max_index_interval: ", p), err) }
    if err := oprot.WriteI32(int32(*p.MaxIndexInterval)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.max_index_interval (46) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 46:max_index_interval: ", p), err) }
  }
  return err
}

func (p *CfDef) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CfDef(%+v)", *p)
}

// Attributes:
//  - Name
//  - StrategyClass
//  - StrategyOptions
//  - ReplicationFactor: @deprecated ignored
//  - CfDefs
//  - DurableWrites
type KsDef struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
  StrategyClass string `thrift:"strategy_class,2,required" db:"strategy_class" json:"strategy_class"`
  StrategyOptions map[string]string `thrift:"strategy_options,3" db:"strategy_options" json:"strategy_options,omitempty"`
  ReplicationFactor *int32 `thrift:"replication_factor,4" db:"replication_factor" json:"replication_factor,omitempty"`
  CfDefs []*CfDef `thrift:"cf_defs,5,required" db:"cf_defs" json:"cf_defs"`
  DurableWrites bool `thrift:"durable_writes,6" db:"durable_writes" json:"durable_writes,omitempty"`
}

func NewKsDef() *KsDef {
  return &KsDef{
DurableWrites: true,
}
}


func (p *KsDef) GetName() string {
  return p.Name
}

func (p *KsDef) GetStrategyClass() string {
  return p.StrategyClass
}
var KsDef_StrategyOptions_DEFAULT map[string]string

func (p *KsDef) GetStrategyOptions() map[string]string {
  return p.StrategyOptions
}
var KsDef_ReplicationFactor_DEFAULT int32
func (p *KsDef) GetReplicationFactor() int32 {
  if !p.IsSetReplicationFactor() {
    return KsDef_ReplicationFactor_DEFAULT
  }
return *p.ReplicationFactor
}

func (p *KsDef) GetCfDefs() []*CfDef {
  return p.CfDefs
}
var KsDef_DurableWrites_DEFAULT bool = true

func (p *KsDef) GetDurableWrites() bool {
  return p.DurableWrites
}
func (p *KsDef) IsSetStrategyOptions() bool {
  return p.StrategyOptions != nil
}

func (p *KsDef) IsSetReplicationFactor() bool {
  return p.ReplicationFactor != nil
}

func (p *KsDef) IsSetDurableWrites() bool {
  return p.DurableWrites != KsDef_DurableWrites_DEFAULT
}

func (p *KsDef) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetStrategyClass bool = false;
  var issetCfDefs bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetName = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStrategyClass = true
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfDefs = true
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetStrategyClass{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StrategyClass is not set"));
  }
  if !issetCfDefs{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDefs is not set"));
  }
  return nil
}

func (p *KsDef)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *KsDef)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StrategyClass = v
}
  return nil
}

func (p *KsDef)  ReadField3(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.StrategyOptions =  tMap
  for i := 0; i < size; i ++ {
var _key22 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key22 = v
}
var _val23 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val23 = v
}
    p.StrategyOptions[_key22] = _val23
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *KsDef)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ReplicationFactor = &v
}
  return nil
}

func (p *KsDef)  ReadField5(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CfDef, 0, size)
  p.CfDefs =  tSlice
  for i := 0; i < size; i ++ {
    _elem24 := &CfDef{
    ColumnType: "Standard",

    ComparatorType: "BytesType",

    Caching: "keys_only",

    SpeculativeRetry: "NONE",

    CellsPerRowToCache: "100",
}
    if err := _elem24.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem24), err)
    }
    p.CfDefs = append(p.CfDefs, _elem24)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KsDef)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.DurableWrites = v
}
  return nil
}

func (p *KsDef) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("KsDef"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KsDef) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *KsDef) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("strategy_class", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:strategy_class: ", p), err) }
  if err := oprot.WriteString(string(p.StrategyClass)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.strategy_class (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:strategy_class: ", p), err) }
  return err
}

func (p *KsDef) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetStrategyOptions() {
    if err := oprot.WriteFieldBegin("strategy_options", thrift.MAP, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:strategy_options: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.StrategyOptions)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.StrategyOptions {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:strategy_options: ", p), err) }
  }
  return err
}

func (p *KsDef) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetReplicationFactor() {
    if err := oprot.WriteFieldBegin("replication_factor", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:replication_factor: ", p), err) }
    if err := oprot.WriteI32(int32(*p.ReplicationFactor)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.replication_factor (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:replication_factor: ", p), err) }
  }
  return err
}

func (p *KsDef) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cf_defs", thrift.LIST, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:cf_defs: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CfDefs)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CfDefs {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:cf_defs: ", p), err) }
  return err
}

func (p *KsDef) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetDurableWrites() {
    if err := oprot.WriteFieldBegin("durable_writes", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:durable_writes: ", p), err) }
    if err := oprot.WriteBool(bool(p.DurableWrites)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.durable_writes (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:durable_writes: ", p), err) }
  }
  return err
}

func (p *KsDef) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KsDef(%+v)", *p)
}

// Row returned from a CQL query.
// 
// This struct is used for both CQL2 and CQL3 queries.  For CQL2, the partition key
// is special-cased and is always returned.  For CQL3, it is not special cased;
// it will be included in the columns list if it was included in the SELECT and
// the key field is always null.
// 
// Attributes:
//  - Key
//  - Columns
type CqlRow struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  Columns []*Column `thrift:"columns,2,required" db:"columns" json:"columns"`
}

func NewCqlRow() *CqlRow {
  return &CqlRow{}
}


func (p *CqlRow) GetKey() []byte {
  return p.Key
}

func (p *CqlRow) GetColumns() []*Column {
  return p.Columns
}
func (p *CqlRow) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumns bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumns = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumns{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"));
  }
  return nil
}

func (p *CqlRow)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CqlRow)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Column, 0, size)
  p.Columns =  tSlice
  for i := 0; i < size; i ++ {
    _elem25 := &Column{}
    if err := _elem25.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem25), err)
    }
    p.Columns = append(p.Columns, _elem25)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CqlRow) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CqlRow"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CqlRow) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CqlRow) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Columns {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err) }
  return err
}

func (p *CqlRow) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CqlRow(%+v)", *p)
}

// Attributes:
//  - NameTypes
//  - ValueTypes
//  - DefaultNameType
//  - DefaultValueType
type CqlMetadata struct {
  NameTypes map[string]string `thrift:"name_types,1,required" db:"name_types" json:"name_types"`
  ValueTypes map[string]string `thrift:"value_types,2,required" db:"value_types" json:"value_types"`
  DefaultNameType string `thrift:"default_name_type,3,required" db:"default_name_type" json:"default_name_type"`
  DefaultValueType string `thrift:"default_value_type,4,required" db:"default_value_type" json:"default_value_type"`
}

func NewCqlMetadata() *CqlMetadata {
  return &CqlMetadata{}
}


func (p *CqlMetadata) GetNameTypes() map[string]string {
  return p.NameTypes
}

func (p *CqlMetadata) GetValueTypes() map[string]string {
  return p.ValueTypes
}

func (p *CqlMetadata) GetDefaultNameType() string {
  return p.DefaultNameType
}

func (p *CqlMetadata) GetDefaultValueType() string {
  return p.DefaultValueType
}
func (p *CqlMetadata) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetNameTypes bool = false;
  var issetValueTypes bool = false;
  var issetDefaultNameType bool = false;
  var issetDefaultValueType bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetNameTypes = true
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValueTypes = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetDefaultNameType = true
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetDefaultValueType = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetNameTypes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameTypes is not set"));
  }
  if !issetValueTypes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ValueTypes is not set"));
  }
  if !issetDefaultNameType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DefaultNameType is not set"));
  }
  if !issetDefaultValueType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DefaultValueType is not set"));
  }
  return nil
}

func (p *CqlMetadata)  ReadField1(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.NameTypes =  tMap
  for i := 0; i < size; i ++ {
var _key26 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key26 = v
}
var _val27 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val27 = v
}
    p.NameTypes[_key26] = _val27
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CqlMetadata)  ReadField2(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.ValueTypes =  tMap
  for i := 0; i < size; i ++ {
var _key28 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key28 = v
}
var _val29 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val29 = v
}
    p.ValueTypes[_key28] = _val29
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CqlMetadata)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.DefaultNameType = v
}
  return nil
}

func (p *CqlMetadata)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.DefaultValueType = v
}
  return nil
}

func (p *CqlMetadata) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CqlMetadata"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CqlMetadata) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("name_types", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name_types: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.NameTypes)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.NameTypes {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name_types: ", p), err) }
  return err
}

func (p *CqlMetadata) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("value_types", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value_types: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.ValueTypes)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.ValueTypes {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value_types: ", p), err) }
  return err
}

func (p *CqlMetadata) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("default_name_type", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:default_name_type: ", p), err) }
  if err := oprot.WriteString(string(p.DefaultNameType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.default_name_type (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:default_name_type: ", p), err) }
  return err
}

func (p *CqlMetadata) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("default_value_type", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:default_value_type: ", p), err) }
  if err := oprot.WriteString(string(p.DefaultValueType)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.default_value_type (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:default_value_type: ", p), err) }
  return err
}

func (p *CqlMetadata) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CqlMetadata(%+v)", *p)
}

// Attributes:
//  - Type
//  - Rows
//  - Num
//  - Schema
type CqlResult_ struct {
  Type CqlResultType `thrift:"type,1,required" db:"type" json:"type"`
  Rows []*CqlRow `thrift:"rows,2" db:"rows" json:"rows,omitempty"`
  Num *int32 `thrift:"num,3" db:"num" json:"num,omitempty"`
  Schema *CqlMetadata `thrift:"schema,4" db:"schema" json:"schema,omitempty"`
}

func NewCqlResult_() *CqlResult_ {
  return &CqlResult_{}
}


func (p *CqlResult_) GetType() CqlResultType {
  return p.Type
}
var CqlResult__Rows_DEFAULT []*CqlRow

func (p *CqlResult_) GetRows() []*CqlRow {
  return p.Rows
}
var CqlResult__Num_DEFAULT int32
func (p *CqlResult_) GetNum() int32 {
  if !p.IsSetNum() {
    return CqlResult__Num_DEFAULT
  }
return *p.Num
}
var CqlResult__Schema_DEFAULT *CqlMetadata
func (p *CqlResult_) GetSchema() *CqlMetadata {
  if !p.IsSetSchema() {
    return CqlResult__Schema_DEFAULT
  }
return p.Schema
}
func (p *CqlResult_) IsSetRows() bool {
  return p.Rows != nil
}

func (p *CqlResult_) IsSetNum() bool {
  return p.Num != nil
}

func (p *CqlResult_) IsSetSchema() bool {
  return p.Schema != nil
}

func (p *CqlResult_) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetType bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetType = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetType{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"));
  }
  return nil
}

func (p *CqlResult_)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := CqlResultType(v)
  p.Type = temp
}
  return nil
}

func (p *CqlResult_)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CqlRow, 0, size)
  p.Rows =  tSlice
  for i := 0; i < size; i ++ {
    _elem30 := &CqlRow{}
    if err := _elem30.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
    }
    p.Rows = append(p.Rows, _elem30)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CqlResult_)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Num = &v
}
  return nil
}

func (p *CqlResult_)  ReadField4(iprot thrift.TProtocol) error {
  p.Schema = &CqlMetadata{}
  if err := p.Schema.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Schema), err)
  }
  return nil
}

func (p *CqlResult_) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CqlResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CqlResult_) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err) }
  if err := oprot.WriteI32(int32(p.Type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err) }
  return err
}

func (p *CqlResult_) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetRows() {
    if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rows: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Rows)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Rows {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rows: ", p), err) }
  }
  return err
}

func (p *CqlResult_) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetNum() {
    if err := oprot.WriteFieldBegin("num", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:num: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Num)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.num (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:num: ", p), err) }
  }
  return err
}

func (p *CqlResult_) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSchema() {
    if err := oprot.WriteFieldBegin("schema", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:schema: ", p), err) }
    if err := p.Schema.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Schema), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:schema: ", p), err) }
  }
  return err
}

func (p *CqlResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CqlResult_(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Count
//  - VariableTypes
//  - VariableNames
type CqlPreparedResult_ struct {
  ItemId int32 `thrift:"itemId,1,required" db:"itemId" json:"itemId"`
  Count int32 `thrift:"count,2,required" db:"count" json:"count"`
  VariableTypes []string `thrift:"variable_types,3" db:"variable_types" json:"variable_types,omitempty"`
  VariableNames []string `thrift:"variable_names,4" db:"variable_names" json:"variable_names,omitempty"`
}

func NewCqlPreparedResult_() *CqlPreparedResult_ {
  return &CqlPreparedResult_{}
}


func (p *CqlPreparedResult_) GetItemId() int32 {
  return p.ItemId
}

func (p *CqlPreparedResult_) GetCount() int32 {
  return p.Count
}
var CqlPreparedResult__VariableTypes_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableTypes() []string {
  return p.VariableTypes
}
var CqlPreparedResult__VariableNames_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableNames() []string {
  return p.VariableNames
}
func (p *CqlPreparedResult_) IsSetVariableTypes() bool {
  return p.VariableTypes != nil
}

func (p *CqlPreparedResult_) IsSetVariableNames() bool {
  return p.VariableNames != nil
}

func (p *CqlPreparedResult_) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetItemId bool = false;
  var issetCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetItemId = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCount = true
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetItemId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"));
  }
  if !issetCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"));
  }
  return nil
}

func (p *CqlPreparedResult_)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ItemId = v
}
  return nil
}

func (p *CqlPreparedResult_)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *CqlPreparedResult_)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.VariableTypes =  tSlice
  for i := 0; i < size; i ++ {
var _elem31 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem31 = v
}
    p.VariableTypes = append(p.VariableTypes, _elem31)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CqlPreparedResult_)  ReadField4(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.VariableNames =  tSlice
  for i := 0; i < size; i ++ {
var _elem32 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem32 = v
}
    p.VariableNames = append(p.VariableNames, _elem32)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CqlPreparedResult_) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CqlPreparedResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CqlPreparedResult_) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err) }
  if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err) }
  return err
}

func (p *CqlPreparedResult_) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:count: ", p), err) }
  if err := oprot.WriteI32(int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:count: ", p), err) }
  return err
}

func (p *CqlPreparedResult_) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetVariableTypes() {
    if err := oprot.WriteFieldBegin("variable_types", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:variable_types: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableTypes)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VariableTypes {
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:variable_types: ", p), err) }
  }
  return err
}

func (p *CqlPreparedResult_) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetVariableNames() {
    if err := oprot.WriteFieldBegin("variable_names", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:variable_names: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableNames)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VariableNames {
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:variable_names: ", p), err) }
  }
  return err
}

func (p *CqlPreparedResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CqlPreparedResult_(%+v)", *p)
}

// Represents input splits used by hadoop ColumnFamilyRecordReaders
// 
// Attributes:
//  - StartToken
//  - EndToken
//  - RowCount
type CfSplit struct {
  StartToken string `thrift:"start_token,1,required" db:"start_token" json:"start_token"`
  EndToken string `thrift:"end_token,2,required" db:"end_token" json:"end_token"`
  RowCount int64 `thrift:"row_count,3,required" db:"row_count" json:"row_count"`
}

func NewCfSplit() *CfSplit {
  return &CfSplit{}
}


func (p *CfSplit) GetStartToken() string {
  return p.StartToken
}

func (p *CfSplit) GetEndToken() string {
  return p.EndToken
}

func (p *CfSplit) GetRowCount() int64 {
  return p.RowCount
}
func (p *CfSplit) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartToken bool = false;
  var issetEndToken bool = false;
  var issetRowCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartToken = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetEndToken = true
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetRowCount = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"));
  }
  if !issetEndToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"));
  }
  if !issetRowCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RowCount is not set"));
  }
  return nil
}

func (p *CfSplit)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartToken = v
}
  return nil
}

func (p *CfSplit)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EndToken = v
}
  return nil
}

func (p *CfSplit)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.RowCount = v
}
  return nil
}

func (p *CfSplit) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("CfSplit"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CfSplit) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_token: ", p), err) }
  if err := oprot.WriteString(string(p.StartToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_token (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_token: ", p), err) }
  return err
}

func (p *CfSplit) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_token: ", p), err) }
  if err := oprot.WriteString(string(p.EndToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.end_token (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_token: ", p), err) }
  return err
}

func (p *CfSplit) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("row_count", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:row_count: ", p), err) }
  if err := oprot.WriteI64(int64(p.RowCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.row_count (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:row_count: ", p), err) }
  return err
}

func (p *CfSplit) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CfSplit(%+v)", *p)
}

// The ColumnSlice is used to select a set of columns from inside a row.
// If start or finish are unspecified they will default to the start-of
// end-of value.
// @param start. The start of the ColumnSlice inclusive
// @param finish. The end of the ColumnSlice inclusive
// 
// Attributes:
//  - Start
//  - Finish
type ColumnSlice struct {
  Start []byte `thrift:"start,1" db:"start" json:"start,omitempty"`
  Finish []byte `thrift:"finish,2" db:"finish" json:"finish,omitempty"`
}

func NewColumnSlice() *ColumnSlice {
  return &ColumnSlice{}
}

var ColumnSlice_Start_DEFAULT []byte

func (p *ColumnSlice) GetStart() []byte {
  return p.Start
}
var ColumnSlice_Finish_DEFAULT []byte

func (p *ColumnSlice) GetFinish() []byte {
  return p.Finish
}
func (p *ColumnSlice) IsSetStart() bool {
  return p.Start != nil
}

func (p *ColumnSlice) IsSetFinish() bool {
  return p.Finish != nil
}

func (p *ColumnSlice) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ColumnSlice)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Start = v
}
  return nil
}

func (p *ColumnSlice)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Finish = v
}
  return nil
}

func (p *ColumnSlice) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("ColumnSlice"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ColumnSlice) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetStart() {
    if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err) }
    if err := oprot.WriteBinary(p.Start); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.start (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err) }
  }
  return err
}

func (p *ColumnSlice) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetFinish() {
    if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finish: ", p), err) }
    if err := oprot.WriteBinary(p.Finish); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.finish (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finish: ", p), err) }
  }
  return err
}

func (p *ColumnSlice) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ColumnSlice(%+v)", *p)
}

// Used to perform multiple slices on a single row key in one rpc operation
// @param key. The row key to be multi sliced
// @param column_parent. The column family (super columns are unsupported)
// @param column_slices. 0 to many ColumnSlice objects each will be used to select columns
// @param reversed. Direction of slice
// @param count. Maximum number of columns
// @param consistency_level. Level to perform the operation at
// 
// Attributes:
//  - Key
//  - ColumnParent
//  - ColumnSlices
//  - Reversed
//  - Count
//  - ConsistencyLevel
type MultiSliceRequest struct {
  Key []byte `thrift:"key,1" db:"key" json:"key,omitempty"`
  ColumnParent *ColumnParent `thrift:"column_parent,2" db:"column_parent" json:"column_parent,omitempty"`
  ColumnSlices []*ColumnSlice `thrift:"column_slices,3" db:"column_slices" json:"column_slices,omitempty"`
  Reversed bool `thrift:"reversed,4" db:"reversed" json:"reversed,omitempty"`
  Count int32 `thrift:"count,5" db:"count" json:"count,omitempty"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,6" db:"consistency_level" json:"consistency_level,omitempty"`
}

func NewMultiSliceRequest() *MultiSliceRequest {
  return &MultiSliceRequest{
Count: 1000,

ConsistencyLevel: 1,
}
}

var MultiSliceRequest_Key_DEFAULT []byte

func (p *MultiSliceRequest) GetKey() []byte {
  return p.Key
}
var MultiSliceRequest_ColumnParent_DEFAULT *ColumnParent
func (p *MultiSliceRequest) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return MultiSliceRequest_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var MultiSliceRequest_ColumnSlices_DEFAULT []*ColumnSlice

func (p *MultiSliceRequest) GetColumnSlices() []*ColumnSlice {
  return p.ColumnSlices
}
var MultiSliceRequest_Reversed_DEFAULT bool = false

func (p *MultiSliceRequest) GetReversed() bool {
  return p.Reversed
}
var MultiSliceRequest_Count_DEFAULT int32 = 1000

func (p *MultiSliceRequest) GetCount() int32 {
  return p.Count
}
var MultiSliceRequest_ConsistencyLevel_DEFAULT ConsistencyLevel = 1

func (p *MultiSliceRequest) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *MultiSliceRequest) IsSetKey() bool {
  return p.Key != nil
}

func (p *MultiSliceRequest) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *MultiSliceRequest) IsSetColumnSlices() bool {
  return p.ColumnSlices != nil
}

func (p *MultiSliceRequest) IsSetReversed() bool {
  return p.Reversed != MultiSliceRequest_Reversed_DEFAULT
}

func (p *MultiSliceRequest) IsSetCount() bool {
  return p.Count != MultiSliceRequest_Count_DEFAULT
}

func (p *MultiSliceRequest) IsSetConsistencyLevel() bool {
  return p.ConsistencyLevel != MultiSliceRequest_ConsistencyLevel_DEFAULT
}

func (p *MultiSliceRequest) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *MultiSliceRequest)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *MultiSliceRequest)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *MultiSliceRequest)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ColumnSlice, 0, size)
  p.ColumnSlices =  tSlice
  for i := 0; i < size; i ++ {
    _elem33 := &ColumnSlice{}
    if err := _elem33.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem33), err)
    }
    p.ColumnSlices = append(p.ColumnSlices, _elem33)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *MultiSliceRequest)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Reversed = v
}
  return nil
}

func (p *MultiSliceRequest)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *MultiSliceRequest)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *MultiSliceRequest) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("MultiSliceRequest"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *MultiSliceRequest) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetKey() {
    if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
    if err := oprot.WriteBinary(p.Key); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnParent() {
    if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
    if err := p.ColumnParent.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetColumnSlices() {
    if err := oprot.WriteFieldBegin("column_slices", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_slices: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnSlices)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ColumnSlices {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_slices: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetReversed() {
    if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:reversed: ", p), err) }
    if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.reversed (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:reversed: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) writeField5(oprot thrift.TProtocol) (err error) {
  if p.IsSetCount() {
    if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:count: ", p), err) }
    if err := oprot.WriteI32(int32(p.Count)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.count (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:count: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) writeField6(oprot thrift.TProtocol) (err error) {
  if p.IsSetConsistencyLevel() {
    if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:consistency_level: ", p), err) }
    if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.consistency_level (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:consistency_level: ", p), err) }
  }
  return err
}

func (p *MultiSliceRequest) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("MultiSliceRequest(%+v)", *p)
}

type Cassandra interface {
  // Parameters:
  //  - AuthRequest
  Login(ctx context.Context, auth_request *AuthenticationRequest) (err error)
  // Parameters:
  //  - Keyspace
  SetKeyspace(ctx context.Context, keyspace string) (err error)
  // Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
  // the only method that can throw an exception under non-failure conditions.)
  // 
  // Parameters:
  //  - Key
  //  - ColumnPath
  //  - ConsistencyLevel
  Get(ctx context.Context, key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error)
  // Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
  // pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
  // 
  // Parameters:
  //  - Key
  //  - ColumnParent
  //  - Predicate
  //  - ConsistencyLevel
  GetSlice(ctx context.Context, key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error)
  // returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
  // <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
  // 
  // Parameters:
  //  - Key
  //  - ColumnParent
  //  - Predicate
  //  - ConsistencyLevel
  GetCount(ctx context.Context, key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error)
  // Performs a get_slice for column_parent and predicate for the given keys in parallel.
  // 
  // Parameters:
  //  - Keys
  //  - ColumnParent
  //  - Predicate
  //  - ConsistencyLevel
  MultigetSlice(ctx context.Context, keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error)
  // Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
  // 
  // Parameters:
  //  - Keys
  //  - ColumnParent
  //  - Predicate
  //  - ConsistencyLevel
  MultigetCount(ctx context.Context, keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error)
  // returns a subset of columns for a contiguous range of keys.
  // 
  // Parameters:
  //  - ColumnParent
  //  - Predicate
  //  - Range
  //  - ConsistencyLevel
  GetRangeSlices(ctx context.Context, column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
  // returns a range of columns, wrapping to the next rows if necessary to collect max_results.
  // 
  // Parameters:
  //  - ColumnFamily
  //  - Range
  //  - StartColumn
  //  - ConsistencyLevel
  GetPagedSlice(ctx context.Context, column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
  // Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
  // @deprecated use get_range_slices instead with range.row_filter specified
  // 
  // Parameters:
  //  - ColumnParent
  //  - IndexClause
  //  - ColumnPredicate
  //  - ConsistencyLevel
  GetIndexedSlices(ctx context.Context, column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
  // Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
  // 
  // Parameters:
  //  - Key
  //  - ColumnParent
  //  - Column
  //  - ConsistencyLevel
  Insert(ctx context.Context, key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error)
  // Increment or decrement a counter.
  // 
  // Parameters:
  //  - Key
  //  - ColumnParent
  //  - Column
  //  - ConsistencyLevel
  Add(ctx context.Context, key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error)
  // Atomic compare and set.
  // 
  // If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
  // Otherwise, success will be false and current_values will contain the current values for the columns in
  // expected (that, by definition of compare-and-set, will differ from the values in expected).
  // 
  // A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
  // level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
  // The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
  // is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
  // the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
  // guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
  // commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
  // the write.
  // 
  // Parameters:
  //  - Key
  //  - ColumnFamily
  //  - Expected
  //  - Updates
  //  - SerialConsistencyLevel
  //  - CommitConsistencyLevel
  Cas(ctx context.Context, key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error)
  // Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
  // that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
  // row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
  // 
  // Parameters:
  //  - Key
  //  - ColumnPath
  //  - Timestamp
  //  - ConsistencyLevel
  Remove(ctx context.Context, key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error)
  // Remove a counter at the specified location.
  // Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
  // until the delete has reached all the nodes and all of them have been fully compacted.
  // 
  // Parameters:
  //  - Key
  //  - Path
  //  - ConsistencyLevel
  RemoveCounter(ctx context.Context, key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error)
  //   Mutate many columns or super columns for many row keys. See also: Mutation.
  // 
  //   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
  // *
  // 
  // Parameters:
  //  - MutationMap
  //  - ConsistencyLevel
  BatchMutate(ctx context.Context, mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
  //   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
  // 
  //   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
  // *
  // 
  // Parameters:
  //  - MutationMap
  //  - ConsistencyLevel
  AtomicBatchMutate(ctx context.Context, mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
  // Truncate will mark and entire column family as deleted.
  // From the user's perspective a successful call to truncate will result complete data deletion from cfname.
  // Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
  // only marks the data as deleted.
  // The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
  // some hosts are down.
  // 
  // Parameters:
  //  - Cfname
  Truncate(ctx context.Context, cfname string) (err error)
  // Select multiple slices of a key in a single RPC operation
  // 
  // Parameters:
  //  - Request
  GetMultiSlice(ctx context.Context, request *MultiSliceRequest) (r []*ColumnOrSuperColumn, err error)
  // for each schema version present in the cluster, returns a list of nodes at that version.
  // hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
  // the cluster is all on the same version if the size of the map is 1.
  DescribeSchemaVersions(ctx context.Context) (r map[string][]string, err error)
  // list the defined keyspaces in this cluster
  DescribeKeyspaces(ctx context.Context) (r []*KsDef, err error)
  // get the cluster name
  DescribeClusterName(ctx context.Context) (r string, err error)
  // get the thrift api version
  DescribeVersion(ctx context.Context) (r string, err error)
  // get the token ring: a map of ranges to host addresses,
  // represented as a set of TokenRange instead of a map from range
  // to list of endpoints, because you can't use Thrift structs as
  // map keys:
  // https://issues.apache.org/jira/browse/THRIFT-162
  // 
  // for the same reason, we can't return a set here, even though
  // order is neither important nor predictable.
  // 
  // Parameters:
  //  - Keyspace
  DescribeRing(ctx context.Context, keyspace string) (r []*TokenRange, err error)
  // same as describe_ring, but considers only nodes in the local DC
  // 
  // Parameters:
  //  - Keyspace
  DescribeLocalRing(ctx context.Context, keyspace string) (r []*TokenRange, err error)
  // get the mapping between token->node ip
  // without taking replication into consideration
  // https://issues.apache.org/jira/browse/CASSANDRA-4092
  DescribeTokenMap(ctx context.Context) (r map[string]string, err error)
  // returns the partitioner used by this cluster
  DescribePartitioner(ctx context.Context) (r string, err error)
  // returns the snitch used by this cluster
  DescribeSnitch(ctx context.Context) (r string, err error)
  // describe specified keyspace
  // 
  // Parameters:
  //  - Keyspace
  DescribeKeyspace(ctx context.Context, keyspace string) (r *KsDef, err error)
  // experimental API for hadoop/parallel query support.
  // may change violently and without warning.
  // 
  // returns list of token strings such that first subrange is (list[0], list[1]],
  // next is (list[1], list[2]], etc.
  // 
  // Parameters:
  //  - CfName
  //  - StartToken
  //  - EndToken
  //  - KeysPerSplit
  DescribeSplits(ctx context.Context, cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error)
  // Enables tracing for the next query in this connection and returns the UUID for that trace session
  // The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
  TraceNextQuery(ctx context.Context) (r []byte, err error)
  // Parameters:
  //  - CfName
  //  - StartToken
  //  - EndToken
  //  - KeysPerSplit
  DescribeSplitsEx(ctx context.Context, cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error)
  // adds a column family. returns the new schema id.
  // 
  // Parameters:
  //  - CfDef
  SystemAddColumnFamily(ctx context.Context, cf_def *CfDef) (r string, err error)
  // drops a column family. returns the new schema id.
  // 
  // Parameters:
  //  - ColumnFamily
  SystemDropColumnFamily(ctx context.Context, column_family string) (r string, err error)
  // adds a keyspace and any column families that are part of it. returns the new schema id.
  // 
  // Parameters:
  //  - KsDef
  SystemAddKeyspace(ctx context.Context, ks_def *KsDef) (r string, err error)
  // drops a keyspace and any column families that are part of it. returns the new schema id.
  // 
  // Parameters:
  //  - Keyspace
  SystemDropKeyspace(ctx context.Context, keyspace string) (r string, err error)
  // updates properties of a keyspace. returns the new schema id.
  // 
  // Parameters:
  //  - KsDef
  SystemUpdateKeyspace(ctx context.Context, ks_def *KsDef) (r string, err error)
  // updates properties of a column family. returns the new schema id.
  // 
  // Parameters:
  //  - CfDef
  SystemUpdateColumnFamily(ctx context.Context, cf_def *CfDef) (r string, err error)
  // @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
  // 
  // Parameters:
  //  - Query
  //  - Compression
  ExecuteCqlQuery(ctx context.Context, query []byte, compression Compression) (r *CqlResult_, err error)
  // Executes a CQL3 (Cassandra Query Language) statement and returns a
  // CqlResult containing the results.
  // 
  // Parameters:
  //  - Query
  //  - Compression
  //  - Consistency
  ExecuteCql3Query(ctx context.Context, query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error)
  // @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
  // 
  // Parameters:
  //  - Query
  //  - Compression
  PrepareCqlQuery(ctx context.Context, query []byte, compression Compression) (r *CqlPreparedResult_, err error)
  // Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
  // - the type of CQL statement
  // - an id token of the compiled CQL stored on the server side.
  // - a count of the discovered bound markers in the statement
  // 
  // Parameters:
  //  - Query
  //  - Compression
  PrepareCql3Query(ctx context.Context, query []byte, compression Compression) (r *CqlPreparedResult_, err error)
  // @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
  // 
  // Parameters:
  //  - ItemId
  //  - Values
  ExecutePreparedCqlQuery(ctx context.Context, itemId int32, values [][]byte) (r *CqlResult_, err error)
  // Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
  // to bind, and the consistency level, and returns a CqlResult containing the results.
  // 
  // Parameters:
  //  - ItemId
  //  - Values
  //  - Consistency
  ExecutePreparedCql3Query(ctx context.Context, itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error)
  // @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
  // 
  // Parameters:
  //  - Version
  SetCqlVersion(ctx context.Context, version string) (err error)
}

type CassandraClient struct {
  c thrift.TClient
}

// Deprecated: Use NewCassandra instead
func NewCassandraClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *CassandraClient {
  return &CassandraClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

// Deprecated: Use NewCassandra instead
func NewCassandraClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *CassandraClient {
  return &CassandraClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewCassandraClient(c thrift.TClient) *CassandraClient {
  return &CassandraClient{
    c: c,
  }
}

// Parameters:
//  - AuthRequest
func (p *CassandraClient) Login(ctx context.Context, auth_request *AuthenticationRequest) (err error) {
  var _args34 CassandraLoginArgs
  _args34.AuthRequest = auth_request
  var _result35 CassandraLoginResult
  if err = p.c.Call(ctx, "login", &_args34, &_result35); err != nil {
    return
  }
  switch {
  case _result35.Authnx!= nil:
    return _result35.Authnx
  case _result35.Authzx!= nil:
    return _result35.Authzx
  }

  return nil
}

// Parameters:
//  - Keyspace
func (p *CassandraClient) SetKeyspace(ctx context.Context, keyspace string) (err error) {
  var _args36 CassandraSetKeyspaceArgs
  _args36.Keyspace = keyspace
  var _result37 CassandraSetKeyspaceResult
  if err = p.c.Call(ctx, "set_keyspace", &_args36, &_result37); err != nil {
    return
  }
  switch {
  case _result37.Ire!= nil:
    return _result37.Ire
  }

  return nil
}

// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
// the only method that can throw an exception under non-failure conditions.)
// 
// Parameters:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
func (p *CassandraClient) Get(ctx context.Context, key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error) {
  var _args38 CassandraGetArgs
  _args38.Key = key
  _args38.ColumnPath = column_path
  _args38.ConsistencyLevel = consistency_level
  var _result39 CassandraGetResult
  if err = p.c.Call(ctx, "get", &_args38, &_result39); err != nil {
    return
  }
  switch {
  case _result39.Ire!= nil:
    return r, _result39.Ire
  case _result39.Nfe!= nil:
    return r, _result39.Nfe
  case _result39.Ue!= nil:
    return r, _result39.Ue
  case _result39.Te!= nil:
    return r, _result39.Te
  }

  return _result39.GetSuccess(), nil
}

// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
// 
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetSlice(ctx context.Context, key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error) {
  var _args40 CassandraGetSliceArgs
  _args40.Key = key
  _args40.ColumnParent = column_parent
  _args40.Predicate = predicate
  _args40.ConsistencyLevel = consistency_level
  var _result41 CassandraGetSliceResult
  if err = p.c.Call(ctx, "get_slice", &_args40, &_result41); err != nil {
    return
  }
  switch {
  case _result41.Ire!= nil:
    return r, _result41.Ire
  case _result41.Ue!= nil:
    return r, _result41.Ue
  case _result41.Te!= nil:
    return r, _result41.Te
  }

  return _result41.GetSuccess(), nil
}

// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
// 
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetCount(ctx context.Context, key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error) {
  var _args42 CassandraGetCountArgs
  _args42.Key = key
  _args42.ColumnParent = column_parent
  _args42.Predicate = predicate
  _args42.ConsistencyLevel = consistency_level
  var _result43 CassandraGetCountResult
  if err = p.c.Call(ctx, "get_count", &_args42, &_result43); err != nil {
    return
  }
  switch {
  case _result43.Ire!= nil:
    return r, _result43.Ire
  case _result43.Ue!= nil:
    return r, _result43.Ue
  case _result43.Te!= nil:
    return r, _result43.Te
  }

  return _result43.GetSuccess(), nil
}

// Performs a get_slice for column_parent and predicate for the given keys in parallel.
// 
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetSlice(ctx context.Context, keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error) {
  var _args44 CassandraMultigetSliceArgs
  _args44.Keys = keys
  _args44.ColumnParent = column_parent
  _args44.Predicate = predicate
  _args44.ConsistencyLevel = consistency_level
  var _result45 CassandraMultigetSliceResult
  if err = p.c.Call(ctx, "multiget_slice", &_args44, &_result45); err != nil {
    return
  }
  switch {
  case _result45.Ire!= nil:
    return r, _result45.Ire
  case _result45.Ue!= nil:
    return r, _result45.Ue
  case _result45.Te!= nil:
    return r, _result45.Te
  }

  return _result45.GetSuccess(), nil
}

// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
// 
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetCount(ctx context.Context, keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error) {
  var _args46 CassandraMultigetCountArgs
  _args46.Keys = keys
  _args46.ColumnParent = column_parent
  _args46.Predicate = predicate
  _args46.ConsistencyLevel = consistency_level
  var _result47 CassandraMultigetCountResult
  if err = p.c.Call(ctx, "multiget_count", &_args46, &_result47); err != nil {
    return
  }
  switch {
  case _result47.Ire!= nil:
    return r, _result47.Ire
  case _result47.Ue!= nil:
    return r, _result47.Ue
  case _result47.Te!= nil:
    return r, _result47.Te
  }

  return _result47.GetSuccess(), nil
}

// returns a subset of columns for a contiguous range of keys.
// 
// Parameters:
//  - ColumnParent
//  - Predicate
//  - Range
//  - ConsistencyLevel
func (p *CassandraClient) GetRangeSlices(ctx context.Context, column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
  var _args48 CassandraGetRangeSlicesArgs
  _args48.ColumnParent = column_parent
  _args48.Predicate = predicate
  _args48.Range = range_a1
  _args48.ConsistencyLevel = consistency_level
  var _result49 CassandraGetRangeSlicesResult
  if err = p.c.Call(ctx, "get_range_slices", &_args48, &_result49); err != nil {
    return
  }
  switch {
  case _result49.Ire!= nil:
    return r, _result49.Ire
  case _result49.Ue!= nil:
    return r, _result49.Ue
  case _result49.Te!= nil:
    return r, _result49.Te
  }

  return _result49.GetSuccess(), nil
}

// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
// 
// Parameters:
//  - ColumnFamily
//  - Range
//  - StartColumn
//  - ConsistencyLevel
func (p *CassandraClient) GetPagedSlice(ctx context.Context, column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
  var _args50 CassandraGetPagedSliceArgs
  _args50.ColumnFamily = column_family
  _args50.Range = range_a1
  _args50.StartColumn = start_column
  _args50.ConsistencyLevel = consistency_level
  var _result51 CassandraGetPagedSliceResult
  if err = p.c.Call(ctx, "get_paged_slice", &_args50, &_result51); err != nil {
    return
  }
  switch {
  case _result51.Ire!= nil:
    return r, _result51.Ire
  case _result51.Ue!= nil:
    return r, _result51.Ue
  case _result51.Te!= nil:
    return r, _result51.Te
  }

  return _result51.GetSuccess(), nil
}

// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
// @deprecated use get_range_slices instead with range.row_filter specified
// 
// Parameters:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
func (p *CassandraClient) GetIndexedSlices(ctx context.Context, column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
  var _args52 CassandraGetIndexedSlicesArgs
  _args52.ColumnParent = column_parent
  _args52.IndexClause = index_clause
  _args52.ColumnPredicate = column_predicate
  _args52.ConsistencyLevel = consistency_level
  var _result53 CassandraGetIndexedSlicesResult
  if err = p.c.Call(ctx, "get_indexed_slices", &_args52, &_result53); err != nil {
    return
  }
  switch {
  case _result53.Ire!= nil:
    return r, _result53.Ire
  case _result53.Ue!= nil:
    return r, _result53.Ue
  case _result53.Te!= nil:
    return r, _result53.Te
  }

  return _result53.GetSuccess(), nil
}

// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
// 
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Insert(ctx context.Context, key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
  var _args54 CassandraInsertArgs
  _args54.Key = key
  _args54.ColumnParent = column_parent
  _args54.Column = column
  _args54.ConsistencyLevel = consistency_level
  var _result55 CassandraInsertResult
  if err = p.c.Call(ctx, "insert", &_args54, &_result55); err != nil {
    return
  }
  switch {
  case _result55.Ire!= nil:
    return _result55.Ire
  case _result55.Ue!= nil:
    return _result55.Ue
  case _result55.Te!= nil:
    return _result55.Te
  }

  return nil
}

// Increment or decrement a counter.
// 
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Add(ctx context.Context, key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
  var _args56 CassandraAddArgs
  _args56.Key = key
  _args56.ColumnParent = column_parent
  _args56.Column = column
  _args56.ConsistencyLevel = consistency_level
  var _result57 CassandraAddResult
  if err = p.c.Call(ctx, "add", &_args56, &_result57); err != nil {
    return
  }
  switch {
  case _result57.Ire!= nil:
    return _result57.Ire
  case _result57.Ue!= nil:
    return _result57.Ue
  case _result57.Te!= nil:
    return _result57.Te
  }

  return nil
}

// Atomic compare and set.
// 
// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
// Otherwise, success will be false and current_values will contain the current values for the columns in
// expected (that, by definition of compare-and-set, will differ from the values in expected).
// 
// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
// the write.
// 
// Parameters:
//  - Key
//  - ColumnFamily
//  - Expected
//  - Updates
//  - SerialConsistencyLevel
//  - CommitConsistencyLevel
func (p *CassandraClient) Cas(ctx context.Context, key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error) {
  var _args58 CassandraCasArgs
  _args58.Key = key
  _args58.ColumnFamily = column_family
  _args58.Expected = expected
  _args58.Updates = updates
  _args58.SerialConsistencyLevel = serial_consistency_level
  _args58.CommitConsistencyLevel = commit_consistency_level
  var _result59 CassandraCasResult
  if err = p.c.Call(ctx, "cas", &_args58, &_result59); err != nil {
    return
  }
  switch {
  case _result59.Ire!= nil:
    return r, _result59.Ire
  case _result59.Ue!= nil:
    return r, _result59.Ue
  case _result59.Te!= nil:
    return r, _result59.Te
  }

  return _result59.GetSuccess(), nil
}

// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
// 
// Parameters:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
func (p *CassandraClient) Remove(ctx context.Context, key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
  var _args60 CassandraRemoveArgs
  _args60.Key = key
  _args60.ColumnPath = column_path
  _args60.Timestamp = timestamp
  _args60.ConsistencyLevel = consistency_level
  var _result61 CassandraRemoveResult
  if err = p.c.Call(ctx, "remove", &_args60, &_result61); err != nil {
    return
  }
  switch {
  case _result61.Ire!= nil:
    return _result61.Ire
  case _result61.Ue!= nil:
    return _result61.Ue
  case _result61.Te!= nil:
    return _result61.Te
  }

  return nil
}

// Remove a counter at the specified location.
// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
// until the delete has reached all the nodes and all of them have been fully compacted.
// 
// Parameters:
//  - Key
//  - Path
//  - ConsistencyLevel
func (p *CassandraClient) RemoveCounter(ctx context.Context, key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
  var _args62 CassandraRemoveCounterArgs
  _args62.Key = key
  _args62.Path = path
  _args62.ConsistencyLevel = consistency_level
  var _result63 CassandraRemoveCounterResult
  if err = p.c.Call(ctx, "remove_counter", &_args62, &_result63); err != nil {
    return
  }
  switch {
  case _result63.Ire!= nil:
    return _result63.Ire
  case _result63.Ue!= nil:
    return _result63.Ue
  case _result63.Te!= nil:
    return _result63.Te
  }

  return nil
}

//   Mutate many columns or super columns for many row keys. See also: Mutation.
// 
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
// 
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) BatchMutate(ctx context.Context, mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
  var _args64 CassandraBatchMutateArgs
  _args64.MutationMap = mutation_map
  _args64.ConsistencyLevel = consistency_level
  var _result65 CassandraBatchMutateResult
  if err = p.c.Call(ctx, "batch_mutate", &_args64, &_result65); err != nil {
    return
  }
  switch {
  case _result65.Ire!= nil:
    return _result65.Ire
  case _result65.Ue!= nil:
    return _result65.Ue
  case _result65.Te!= nil:
    return _result65.Te
  }

  return nil
}

//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
// 
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
// 
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) AtomicBatchMutate(ctx context.Context, mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
  var _args66 CassandraAtomicBatchMutateArgs
  _args66.MutationMap = mutation_map
  _args66.ConsistencyLevel = consistency_level
  var _result67 CassandraAtomicBatchMutateResult
  if err = p.c.Call(ctx, "atomic_batch_mutate", &_args66, &_result67); err != nil {
    return
  }
  switch {
  case _result67.Ire!= nil:
    return _result67.Ire
  case _result67.Ue!= nil:
    return _result67.Ue
  case _result67.Te!= nil:
    return _result67.Te
  }

  return nil
}

// Truncate will mark and entire column family as deleted.
// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
// only marks the data as deleted.
// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
// some hosts are down.
// 
// Parameters:
//  - Cfname
func (p *CassandraClient) Truncate(ctx context.Context, cfname string) (err error) {
  var _args68 CassandraTruncateArgs
  _args68.Cfname = cfname
  var _result69 CassandraTruncateResult
  if err = p.c.Call(ctx, "truncate", &_args68, &_result69); err != nil {
    return
  }
  switch {
  case _result69.Ire!= nil:
    return _result69.Ire
  case _result69.Ue!= nil:
    return _result69.Ue
  case _result69.Te!= nil:
    return _result69.Te
  }

  return nil
}

// Select multiple slices of a key in a single RPC operation
// 
// Parameters:
//  - Request
func (p *CassandraClient) GetMultiSlice(ctx context.Context, request *MultiSliceRequest) (r []*ColumnOrSuperColumn, err error) {
  var _args70 CassandraGetMultiSliceArgs
  _args70.Request = request
  var _result71 CassandraGetMultiSliceResult
  if err = p.c.Call(ctx, "get_multi_slice", &_args70, &_result71); err != nil {
    return
  }
  switch {
  case _result71.Ire!= nil:
    return r, _result71.Ire
  case _result71.Ue!= nil:
    return r, _result71.Ue
  case _result71.Te!= nil:
    return r, _result71.Te
  }

  return _result71.GetSuccess(), nil
}

// for each schema version present in the cluster, returns a list of nodes at that version.
// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
// the cluster is all on the same version if the size of the map is 1.
func (p *CassandraClient) DescribeSchemaVersions(ctx context.Context) (r map[string][]string, err error) {
  var _args72 CassandraDescribeSchemaVersionsArgs
  var _result73 CassandraDescribeSchemaVersionsResult
  if err = p.c.Call(ctx, "describe_schema_versions", &_args72, &_result73); err != nil {
    return
  }
  switch {
  case _result73.Ire!= nil:
    return r, _result73.Ire
  }

  return _result73.GetSuccess(), nil
}

// list the defined keyspaces in this cluster
func (p *CassandraClient) DescribeKeyspaces(ctx context.Context) (r []*KsDef, err error) {
  var _args74 CassandraDescribeKeyspacesArgs
  var _result75 CassandraDescribeKeyspacesResult
  if err = p.c.Call(ctx, "describe_keyspaces", &_args74, &_result75); err != nil {
    return
  }
  switch {
  case _result75.Ire!= nil:
    return r, _result75.Ire
  }

  return _result75.GetSuccess(), nil
}

// get the cluster name
func (p *CassandraClient) DescribeClusterName(ctx context.Context) (r string, err error) {
  var _args76 CassandraDescribeClusterNameArgs
  var _result77 CassandraDescribeClusterNameResult
  if err = p.c.Call(ctx, "describe_cluster_name", &_args76, &_result77); err != nil {
    return
  }
  return _result77.GetSuccess(), nil
}

// get the thrift api version
func (p *CassandraClient) DescribeVersion(ctx context.Context) (r string, err error) {
  var _args78 CassandraDescribeVersionArgs
  var _result79 CassandraDescribeVersionResult
  if err = p.c.Call(ctx, "describe_version", &_args78, &_result79); err != nil {
    return
  }
  return _result79.GetSuccess(), nil
}

// get the token ring: a map of ranges to host addresses,
// represented as a set of TokenRange instead of a map from range
// to list of endpoints, because you can't use Thrift structs as
// map keys:
// https://issues.apache.org/jira/browse/THRIFT-162
// 
// for the same reason, we can't return a set here, even though
// order is neither important nor predictable.
// 
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeRing(ctx context.Context, keyspace string) (r []*TokenRange, err error) {
  var _args80 CassandraDescribeRingArgs
  _args80.Keyspace = keyspace
  var _result81 CassandraDescribeRingResult
  if err = p.c.Call(ctx, "describe_ring", &_args80, &_result81); err != nil {
    return
  }
  switch {
  case _result81.Ire!= nil:
    return r, _result81.Ire
  }

  return _result81.GetSuccess(), nil
}

// same as describe_ring, but considers only nodes in the local DC
// 
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeLocalRing(ctx context.Context, keyspace string) (r []*TokenRange, err error) {
  var _args82 CassandraDescribeLocalRingArgs
  _args82.Keyspace = keyspace
  var _result83 CassandraDescribeLocalRingResult
  if err = p.c.Call(ctx, "describe_local_ring", &_args82, &_result83); err != nil {
    return
  }
  switch {
  case _result83.Ire!= nil:
    return r, _result83.Ire
  }

  return _result83.GetSuccess(), nil
}

// get the mapping between token->node ip
// without taking replication into consideration
// https://issues.apache.org/jira/browse/CASSANDRA-4092
func (p *CassandraClient) DescribeTokenMap(ctx context.Context) (r map[string]string, err error) {
  var _args84 CassandraDescribeTokenMapArgs
  var _result85 CassandraDescribeTokenMapResult
  if err = p.c.Call(ctx, "describe_token_map", &_args84, &_result85); err != nil {
    return
  }
  switch {
  case _result85.Ire!= nil:
    return r, _result85.Ire
  }

  return _result85.GetSuccess(), nil
}

// returns the partitioner used by this cluster
func (p *CassandraClient) DescribePartitioner(ctx context.Context) (r string, err error) {
  var _args86 CassandraDescribePartitionerArgs
  var _result87 CassandraDescribePartitionerResult
  if err = p.c.Call(ctx, "describe_partitioner", &_args86, &_result87); err != nil {
    return
  }
  return _result87.GetSuccess(), nil
}

// returns the snitch used by this cluster
func (p *CassandraClient) DescribeSnitch(ctx context.Context) (r string, err error) {
  var _args88 CassandraDescribeSnitchArgs
  var _result89 CassandraDescribeSnitchResult
  if err = p.c.Call(ctx, "describe_snitch", &_args88, &_result89); err != nil {
    return
  }
  return _result89.GetSuccess(), nil
}

// describe specified keyspace
// 
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeKeyspace(ctx context.Context, keyspace string) (r *KsDef, err error) {
  var _args90 CassandraDescribeKeyspaceArgs
  _args90.Keyspace = keyspace
  var _result91 CassandraDescribeKeyspaceResult
  if err = p.c.Call(ctx, "describe_keyspace", &_args90, &_result91); err != nil {
    return
  }
  switch {
  case _result91.Nfe!= nil:
    return r, _result91.Nfe
  case _result91.Ire!= nil:
    return r, _result91.Ire
  }

  return _result91.GetSuccess(), nil
}

// experimental API for hadoop/parallel query support.
// may change violently and without warning.
// 
// returns list of token strings such that first subrange is (list[0], list[1]],
// next is (list[1], list[2]], etc.
// 
// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplits(ctx context.Context, cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error) {
  var _args92 CassandraDescribeSplitsArgs
  _args92.CfName = cfName
  _args92.StartToken = start_token
  _args92.EndToken = end_token
  _args92.KeysPerSplit = keys_per_split
  var _result93 CassandraDescribeSplitsResult
  if err = p.c.Call(ctx, "describe_splits", &_args92, &_result93); err != nil {
    return
  }
  switch {
  case _result93.Ire!= nil:
    return r, _result93.Ire
  }

  return _result93.GetSuccess(), nil
}

// Enables tracing for the next query in this connection and returns the UUID for that trace session
// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
func (p *CassandraClient) TraceNextQuery(ctx context.Context) (r []byte, err error) {
  var _args94 CassandraTraceNextQueryArgs
  var _result95 CassandraTraceNextQueryResult
  if err = p.c.Call(ctx, "trace_next_query", &_args94, &_result95); err != nil {
    return
  }
  return _result95.GetSuccess(), nil
}

// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplitsEx(ctx context.Context, cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error) {
  var _args96 CassandraDescribeSplitsExArgs
  _args96.CfName = cfName
  _args96.StartToken = start_token
  _args96.EndToken = end_token
  _args96.KeysPerSplit = keys_per_split
  var _result97 CassandraDescribeSplitsExResult
  if err = p.c.Call(ctx, "describe_splits_ex", &_args96, &_result97); err != nil {
    return
  }
  switch {
  case _result97.Ire!= nil:
    return r, _result97.Ire
  }

  return _result97.GetSuccess(), nil
}

// adds a column family. returns the new schema id.
// 
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemAddColumnFamily(ctx context.Context, cf_def *CfDef) (r string, err error) {
  var _args98 CassandraSystemAddColumnFamilyArgs
  _args98.CfDef = cf_def
  var _result99 CassandraSystemAddColumnFamilyResult
  if err = p.c.Call(ctx, "system_add_column_family", &_args98, &_result99); err != nil {
    return
  }
  switch {
  case _result99.Ire!= nil:
    return r, _result99.Ire
  case _result99.Sde!= nil:
    return r, _result99.Sde
  }

  return _result99.GetSuccess(), nil
}

// drops a column family. returns the new schema id.
// 
// Parameters:
//  - ColumnFamily
func (p *CassandraClient) SystemDropColumnFamily(ctx context.Context, column_family string) (r string, err error) {
  var _args100 CassandraSystemDropColumnFamilyArgs
  _args100.ColumnFamily = column_family
  var _result101 CassandraSystemDropColumnFamilyResult
  if err = p.c.Call(ctx, "system_drop_column_family", &_args100, &_result101); err != nil {
    return
  }
  switch {
  case _result101.Ire!= nil:
    return r, _result101.Ire
  case _result101.Sde!= nil:
    return r, _result101.Sde
  }

  return _result101.GetSuccess(), nil
}

// adds a keyspace and any column families that are part of it. returns the new schema id.
// 
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemAddKeyspace(ctx context.Context, ks_def *KsDef) (r string, err error) {
  var _args102 CassandraSystemAddKeyspaceArgs
  _args102.KsDef = ks_def
  var _result103 CassandraSystemAddKeyspaceResult
  if err = p.c.Call(ctx, "system_add_keyspace", &_args102, &_result103); err != nil {
    return
  }
  switch {
  case _result103.Ire!= nil:
    return r, _result103.Ire
  case _result103.Sde!= nil:
    return r, _result103.Sde
  }

  return _result103.GetSuccess(), nil
}

// drops a keyspace and any column families that are part of it. returns the new schema id.
// 
// Parameters:
//  - Keyspace
func (p *CassandraClient) SystemDropKeyspace(ctx context.Context, keyspace string) (r string, err error) {
  var _args104 CassandraSystemDropKeyspaceArgs
  _args104.Keyspace = keyspace
  var _result105 CassandraSystemDropKeyspaceResult
  if err = p.c.Call(ctx, "system_drop_keyspace", &_args104, &_result105); err != nil {
    return
  }
  switch {
  case _result105.Ire!= nil:
    return r, _result105.Ire
  case _result105.Sde!= nil:
    return r, _result105.Sde
  }

  return _result105.GetSuccess(), nil
}

// updates properties of a keyspace. returns the new schema id.
// 
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemUpdateKeyspace(ctx context.Context, ks_def *KsDef) (r string, err error) {
  var _args106 CassandraSystemUpdateKeyspaceArgs
  _args106.KsDef = ks_def
  var _result107 CassandraSystemUpdateKeyspaceResult
  if err = p.c.Call(ctx, "system_update_keyspace", &_args106, &_result107); err != nil {
    return
  }
  switch {
  case _result107.Ire!= nil:
    return r, _result107.Ire
  case _result107.Sde!= nil:
    return r, _result107.Sde
  }

  return _result107.GetSuccess(), nil
}

// updates properties of a column family. returns the new schema id.
// 
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemUpdateColumnFamily(ctx context.Context, cf_def *CfDef) (r string, err error) {
  var _args108 CassandraSystemUpdateColumnFamilyArgs
  _args108.CfDef = cf_def
  var _result109 CassandraSystemUpdateColumnFamilyResult
  if err = p.c.Call(ctx, "system_update_column_family", &_args108, &_result109); err != nil {
    return
  }
  switch {
  case _result109.Ire!= nil:
    return r, _result109.Ire
  case _result109.Sde!= nil:
    return r, _result109.Sde
  }

  return _result109.GetSuccess(), nil
}

// @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
// 
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) ExecuteCqlQuery(ctx context.Context, query []byte, compression Compression) (r *CqlResult_, err error) {
  var _args110 CassandraExecuteCqlQueryArgs
  _args110.Query = query
  _args110.Compression = compression
  var _result111 CassandraExecuteCqlQueryResult
  if err = p.c.Call(ctx, "execute_cql_query", &_args110, &_result111); err != nil {
    return
  }
  switch {
  case _result111.Ire!= nil:
    return r, _result111.Ire
  case _result111.Ue!= nil:
    return r, _result111.Ue
  case _result111.Te!= nil:
    return r, _result111.Te
  case _result111.Sde!= nil:
    return r, _result111.Sde
  }

  return _result111.GetSuccess(), nil
}

// Executes a CQL3 (Cassandra Query Language) statement and returns a
// CqlResult containing the results.
// 
// Parameters:
//  - Query
//  - Compression
//  - Consistency
func (p *CassandraClient) ExecuteCql3Query(ctx context.Context, query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error) {
  var _args112 CassandraExecuteCql3QueryArgs
  _args112.Query = query
  _args112.Compression = compression
  _args112.Consistency = consistency
  var _result113 CassandraExecuteCql3QueryResult
  if err = p.c.Call(ctx, "execute_cql3_query", &_args112, &_result113); err != nil {
    return
  }
  switch {
  case _result113.Ire!= nil:
    return r, _result113.Ire
  case _result113.Ue!= nil:
    return r, _result113.Ue
  case _result113.Te!= nil:
    return r, _result113.Te
  case _result113.Sde!= nil:
    return r, _result113.Sde
  }

  return _result113.GetSuccess(), nil
}

// @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
// 
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCqlQuery(ctx context.Context, query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
  var _args114 CassandraPrepareCqlQueryArgs
  _args114.Query = query
  _args114.Compression = compression
  var _result115 CassandraPrepareCqlQueryResult
  if err = p.c.Call(ctx, "prepare_cql_query", &_args114, &_result115); err != nil {
    return
  }
  switch {
  case _result115.Ire!= nil:
    return r, _result115.Ire
  }

  return _result115.GetSuccess(), nil
}

// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
// - the type of CQL statement
// - an id token of the compiled CQL stored on the server side.
// - a count of the discovered bound markers in the statement
// 
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCql3Query(ctx context.Context, query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
  var _args116 CassandraPrepareCql3QueryArgs
  _args116.Query = query
  _args116.Compression = compression
  var _result117 CassandraPrepareCql3QueryResult
  if err = p.c.Call(ctx, "prepare_cql3_query", &_args116, &_result117); err != nil {
    return
  }
  switch {
  case _result117.Ire!= nil:
    return r, _result117.Ire
  }

  return _result117.GetSuccess(), nil
}

// @deprecated Throws InvalidRequestException since 2.2. Please use the CQL3 version instead.
// 
// Parameters:
//  - ItemId
//  - Values
func (p *CassandraClient) ExecutePreparedCqlQuery(ctx context.Context, itemId int32, values [][]byte) (r *CqlResult_, err error) {
  var _args118 CassandraExecutePreparedCqlQueryArgs
  _args118.ItemId = itemId
  _args118.Values = values
  var _result119 CassandraExecutePreparedCqlQueryResult
  if err = p.c.Call(ctx, "execute_prepared_cql_query", &_args118, &_result119); err != nil {
    return
  }
  switch {
  case _result119.Ire!= nil:
    return r, _result119.Ire
  case _result119.Ue!= nil:
    return r, _result119.Ue
  case _result119.Te!= nil:
    return r, _result119.Te
  case _result119.Sde!= nil:
    return r, _result119.Sde
  }

  return _result119.GetSuccess(), nil
}

// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
// to bind, and the consistency level, and returns a CqlResult containing the results.
// 
// Parameters:
//  - ItemId
//  - Values
//  - Consistency
func (p *CassandraClient) ExecutePreparedCql3Query(ctx context.Context, itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error) {
  var _args120 CassandraExecutePreparedCql3QueryArgs
  _args120.ItemId = itemId
  _args120.Values = values
  _args120.Consistency = consistency
  var _result121 CassandraExecutePreparedCql3QueryResult
  if err = p.c.Call(ctx, "execute_prepared_cql3_query", &_args120, &_result121); err != nil {
    return
  }
  switch {
  case _result121.Ire!= nil:
    return r, _result121.Ire
  case _result121.Ue!= nil:
    return r, _result121.Ue
  case _result121.Te!= nil:
    return r, _result121.Te
  case _result121.Sde!= nil:
    return r, _result121.Sde
  }

  return _result121.GetSuccess(), nil
}

// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
// 
// Parameters:
//  - Version
func (p *CassandraClient) SetCqlVersion(ctx context.Context, version string) (err error) {
  var _args122 CassandraSetCqlVersionArgs
  _args122.Version = version
  var _result123 CassandraSetCqlVersionResult
  if err = p.c.Call(ctx, "set_cql_version", &_args122, &_result123); err != nil {
    return
  }
  switch {
  case _result123.Ire!= nil:
    return _result123.Ire
  }

  return nil
}

type CassandraProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler Cassandra
}

func (p *CassandraProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *CassandraProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *CassandraProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewCassandraProcessor(handler Cassandra) *CassandraProcessor {

  self124 := &CassandraProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self124.processorMap["login"] = &cassandraProcessorLogin{handler:handler}
  self124.processorMap["set_keyspace"] = &cassandraProcessorSetKeyspace{handler:handler}
  self124.processorMap["get"] = &cassandraProcessorGet{handler:handler}
  self124.processorMap["get_slice"] = &cassandraProcessorGetSlice{handler:handler}
  self124.processorMap["get_count"] = &cassandraProcessorGetCount{handler:handler}
  self124.processorMap["multiget_slice"] = &cassandraProcessorMultigetSlice{handler:handler}
  self124.processorMap["multiget_count"] = &cassandraProcessorMultigetCount{handler:handler}
  self124.processorMap["get_range_slices"] = &cassandraProcessorGetRangeSlices{handler:handler}
  self124.processorMap["get_paged_slice"] = &cassandraProcessorGetPagedSlice{handler:handler}
  self124.processorMap["get_indexed_slices"] = &cassandraProcessorGetIndexedSlices{handler:handler}
  self124.processorMap["insert"] = &cassandraProcessorInsert{handler:handler}
  self124.processorMap["add"] = &cassandraProcessorAdd{handler:handler}
  self124.processorMap["cas"] = &cassandraProcessorCas{handler:handler}
  self124.processorMap["remove"] = &cassandraProcessorRemove{handler:handler}
  self124.processorMap["remove_counter"] = &cassandraProcessorRemoveCounter{handler:handler}
  self124.processorMap["batch_mutate"] = &cassandraProcessorBatchMutate{handler:handler}
  self124.processorMap["atomic_batch_mutate"] = &cassandraProcessorAtomicBatchMutate{handler:handler}
  self124.processorMap["truncate"] = &cassandraProcessorTruncate{handler:handler}
  self124.processorMap["get_multi_slice"] = &cassandraProcessorGetMultiSlice{handler:handler}
  self124.processorMap["describe_schema_versions"] = &cassandraProcessorDescribeSchemaVersions{handler:handler}
  self124.processorMap["describe_keyspaces"] = &cassandraProcessorDescribeKeyspaces{handler:handler}
  self124.processorMap["describe_cluster_name"] = &cassandraProcessorDescribeClusterName{handler:handler}
  self124.processorMap["describe_version"] = &cassandraProcessorDescribeVersion{handler:handler}
  self124.processorMap["describe_ring"] = &cassandraProcessorDescribeRing{handler:handler}
  self124.processorMap["describe_local_ring"] = &cassandraProcessorDescribeLocalRing{handler:handler}
  self124.processorMap["describe_token_map"] = &cassandraProcessorDescribeTokenMap{handler:handler}
  self124.processorMap["describe_partitioner"] = &cassandraProcessorDescribePartitioner{handler:handler}
  self124.processorMap["describe_snitch"] = &cassandraProcessorDescribeSnitch{handler:handler}
  self124.processorMap["describe_keyspace"] = &cassandraProcessorDescribeKeyspace{handler:handler}
  self124.processorMap["describe_splits"] = &cassandraProcessorDescribeSplits{handler:handler}
  self124.processorMap["trace_next_query"] = &cassandraProcessorTraceNextQuery{handler:handler}
  self124.processorMap["describe_splits_ex"] = &cassandraProcessorDescribeSplitsEx{handler:handler}
  self124.processorMap["system_add_column_family"] = &cassandraProcessorSystemAddColumnFamily{handler:handler}
  self124.processorMap["system_drop_column_family"] = &cassandraProcessorSystemDropColumnFamily{handler:handler}
  self124.processorMap["system_add_keyspace"] = &cassandraProcessorSystemAddKeyspace{handler:handler}
  self124.processorMap["system_drop_keyspace"] = &cassandraProcessorSystemDropKeyspace{handler:handler}
  self124.processorMap["system_update_keyspace"] = &cassandraProcessorSystemUpdateKeyspace{handler:handler}
  self124.processorMap["system_update_column_family"] = &cassandraProcessorSystemUpdateColumnFamily{handler:handler}
  self124.processorMap["execute_cql_query"] = &cassandraProcessorExecuteCqlQuery{handler:handler}
  self124.processorMap["execute_cql3_query"] = &cassandraProcessorExecuteCql3Query{handler:handler}
  self124.processorMap["prepare_cql_query"] = &cassandraProcessorPrepareCqlQuery{handler:handler}
  self124.processorMap["prepare_cql3_query"] = &cassandraProcessorPrepareCql3Query{handler:handler}
  self124.processorMap["execute_prepared_cql_query"] = &cassandraProcessorExecutePreparedCqlQuery{handler:handler}
  self124.processorMap["execute_prepared_cql3_query"] = &cassandraProcessorExecutePreparedCql3Query{handler:handler}
  self124.processorMap["set_cql_version"] = &cassandraProcessorSetCqlVersion{handler:handler}
return self124
}

func (p *CassandraProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err := iprot.ReadMessageBegin()
  if err != nil { return false, err }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(thrift.STRUCT)
  iprot.ReadMessageEnd()
  x125 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
  x125.Write(oprot)
  oprot.WriteMessageEnd()
  oprot.Flush()
  return false, x125

}

type cassandraProcessorLogin struct {
  handler Cassandra
}

func (p *cassandraProcessorLogin) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraLoginArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraLoginResult{}
  var err2 error
  if err2 = p.handler.Login(ctx, args.AuthRequest); err2 != nil {
  switch v := err2.(type) {
    case *AuthenticationException:
  result.Authnx = v
    case *AuthorizationException:
  result.Authzx = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing login: " + err2.Error())
    oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("login", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSetKeyspace struct {
  handler Cassandra
}

func (p *cassandraProcessorSetKeyspace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSetKeyspaceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSetKeyspaceResult{}
  var err2 error
  if err2 = p.handler.SetKeyspace(ctx, args.Keyspace); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_keyspace: " + err2.Error())
    oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("set_keyspace", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGet struct {
  handler Cassandra
}

func (p *cassandraProcessorGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetResult{}
var retval *ColumnOrSuperColumn
  var err2 error
  if retval, err2 = p.handler.Get(ctx, args.Key, args.ColumnPath, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *NotFoundException:
  result.Nfe = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: " + err2.Error())
    oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetSlice struct {
  handler Cassandra
}

func (p *cassandraProcessorGetSlice) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetSliceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetSliceResult{}
var retval []*ColumnOrSuperColumn
  var err2 error
  if retval, err2 = p.handler.GetSlice(ctx, args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_slice: " + err2.Error())
    oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get_slice", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetCount struct {
  handler Cassandra
}

func (p *cassandraProcessorGetCount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetCountArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetCountResult{}
var retval int32
  var err2 error
  if retval, err2 = p.handler.GetCount(ctx, args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_count: " + err2.Error())
    oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("get_count", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorMultigetSlice struct {
  handler Cassandra
}

func (p *cassandraProcessorMultigetSlice) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraMultigetSliceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraMultigetSliceResult{}
var retval map[string][]*ColumnOrSuperColumn
  var err2 error
  if retval, err2 = p.handler.MultigetSlice(ctx, args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_slice: " + err2.Error())
    oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("multiget_slice", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorMultigetCount struct {
  handler Cassandra
}

func (p *cassandraProcessorMultigetCount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraMultigetCountArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraMultigetCountResult{}
var retval map[string]int32
  var err2 error
  if retval, err2 = p.handler.MultigetCount(ctx, args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_count: " + err2.Error())
    oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("multiget_count", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetRangeSlices struct {
  handler Cassandra
}

func (p *cassandraProcessorGetRangeSlices) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetRangeSlicesArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetRangeSlicesResult{}
var retval []*KeySlice
  var err2 error
  if retval, err2 = p.handler.GetRangeSlices(ctx, args.ColumnParent, args.Predicate, args.Range, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_range_slices: " + err2.Error())
    oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get_range_slices", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetPagedSlice struct {
  handler Cassandra
}

func (p *cassandraProcessorGetPagedSlice) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetPagedSliceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetPagedSliceResult{}
var retval []*KeySlice
  var err2 error
  if retval, err2 = p.handler.GetPagedSlice(ctx, args.ColumnFamily, args.Range, args.StartColumn, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_paged_slice: " + err2.Error())
    oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get_paged_slice", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetIndexedSlices struct {
  handler Cassandra
}

func (p *cassandraProcessorGetIndexedSlices) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetIndexedSlicesArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetIndexedSlicesResult{}
var retval []*KeySlice
  var err2 error
  if retval, err2 = p.handler.GetIndexedSlices(ctx, args.ColumnParent, args.IndexClause, args.ColumnPredicate, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_indexed_slices: " + err2.Error())
    oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get_indexed_slices", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorInsert struct {
  handler Cassandra
}

func (p *cassandraProcessorInsert) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraInsertArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraInsertResult{}
  var err2 error
  if err2 = p.handler.Insert(ctx, args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing insert: " + err2.Error())
    oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("insert", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorAdd struct {
  handler Cassandra
}

func (p *cassandraProcessorAdd) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraAddArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraAddResult{}
  var err2 error
  if err2 = p.handler.Add(ctx, args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing add: " + err2.Error())
    oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("add", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorCas struct {
  handler Cassandra
}

func (p *cassandraProcessorCas) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraCasArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraCasResult{}
var retval *CASResult_
  var err2 error
  if retval, err2 = p.handler.Cas(ctx, args.Key, args.ColumnFamily, args.Expected, args.Updates, args.SerialConsistencyLevel, args.CommitConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cas: " + err2.Error())
    oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("cas", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorRemove struct {
  handler Cassandra
}

func (p *cassandraProcessorRemove) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraRemoveArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraRemoveResult{}
  var err2 error
  if err2 = p.handler.Remove(ctx, args.Key, args.ColumnPath, args.Timestamp, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: " + err2.Error())
    oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorRemoveCounter struct {
  handler Cassandra
}

func (p *cassandraProcessorRemoveCounter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraRemoveCounterArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraRemoveCounterResult{}
  var err2 error
  if err2 = p.handler.RemoveCounter(ctx, args.Key, args.Path, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove_counter: " + err2.Error())
    oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("remove_counter", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorBatchMutate struct {
  handler Cassandra
}

func (p *cassandraProcessorBatchMutate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraBatchMutateArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraBatchMutateResult{}
  var err2 error
  if err2 = p.handler.BatchMutate(ctx, args.MutationMap, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch_mutate: " + err2.Error())
    oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("batch_mutate", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorAtomicBatchMutate struct {
  handler Cassandra
}

func (p *cassandraProcessorAtomicBatchMutate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraAtomicBatchMutateArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraAtomicBatchMutateResult{}
  var err2 error
  if err2 = p.handler.AtomicBatchMutate(ctx, args.MutationMap, args.ConsistencyLevel); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomic_batch_mutate: " + err2.Error())
    oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("atomic_batch_mutate", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorTruncate struct {
  handler Cassandra
}

func (p *cassandraProcessorTruncate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraTruncateArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraTruncateResult{}
  var err2 error
  if err2 = p.handler.Truncate(ctx, args.Cfname); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: " + err2.Error())
    oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("truncate", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorGetMultiSlice struct {
  handler Cassandra
}

func (p *cassandraProcessorGetMultiSlice) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraGetMultiSliceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("get_multi_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraGetMultiSliceResult{}
var retval []*ColumnOrSuperColumn
  var err2 error
  if retval, err2 = p.handler.GetMultiSlice(ctx, args.Request); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_multi_slice: " + err2.Error())
    oprot.WriteMessageBegin("get_multi_slice", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("get_multi_slice", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeSchemaVersions struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeSchemaVersions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeSchemaVersionsArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeSchemaVersionsResult{}
var retval map[string][]string
  var err2 error
  if retval, err2 = p.handler.DescribeSchemaVersions(ctx); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_schema_versions: " + err2.Error())
    oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_schema_versions", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeKeyspaces struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspaces) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeKeyspacesArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeKeyspacesResult{}
var retval []*KsDef
  var err2 error
  if retval, err2 = p.handler.DescribeKeyspaces(ctx); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspaces: " + err2.Error())
    oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_keyspaces", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeClusterName struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeClusterName) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeClusterNameArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeClusterNameResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.DescribeClusterName(ctx); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_cluster_name: " + err2.Error())
    oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("describe_cluster_name", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeVersion struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeVersion) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeVersionArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeVersionResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.DescribeVersion(ctx); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_version: " + err2.Error())
    oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("describe_version", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeRing struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeRing) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeRingArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeRingResult{}
var retval []*TokenRange
  var err2 error
  if retval, err2 = p.handler.DescribeRing(ctx, args.Keyspace); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_ring: " + err2.Error())
    oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_ring", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeLocalRing struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeLocalRing) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeLocalRingArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeLocalRingResult{}
var retval []*TokenRange
  var err2 error
  if retval, err2 = p.handler.DescribeLocalRing(ctx, args.Keyspace); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_local_ring: " + err2.Error())
    oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_local_ring", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeTokenMap struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeTokenMap) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeTokenMapArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeTokenMapResult{}
var retval map[string]string
  var err2 error
  if retval, err2 = p.handler.DescribeTokenMap(ctx); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_token_map: " + err2.Error())
    oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_token_map", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribePartitioner struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribePartitioner) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribePartitionerArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribePartitionerResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.DescribePartitioner(ctx); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_partitioner: " + err2.Error())
    oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("describe_partitioner", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeSnitch struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeSnitch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeSnitchArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeSnitchResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.DescribeSnitch(ctx); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_snitch: " + err2.Error())
    oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("describe_snitch", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeKeyspace struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeKeyspaceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeKeyspaceResult{}
var retval *KsDef
  var err2 error
  if retval, err2 = p.handler.DescribeKeyspace(ctx, args.Keyspace); err2 != nil {
  switch v := err2.(type) {
    case *NotFoundException:
  result.Nfe = v
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspace: " + err2.Error())
    oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_keyspace", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeSplits struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeSplits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeSplitsArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeSplitsResult{}
var retval []string
  var err2 error
  if retval, err2 = p.handler.DescribeSplits(ctx, args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits: " + err2.Error())
    oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_splits", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorTraceNextQuery struct {
  handler Cassandra
}

func (p *cassandraProcessorTraceNextQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraTraceNextQueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraTraceNextQueryResult{}
var retval []byte
  var err2 error
  if retval, err2 = p.handler.TraceNextQuery(ctx); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing trace_next_query: " + err2.Error())
    oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("trace_next_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorDescribeSplitsEx struct {
  handler Cassandra
}

func (p *cassandraProcessorDescribeSplitsEx) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraDescribeSplitsExArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraDescribeSplitsExResult{}
var retval []*CfSplit
  var err2 error
  if retval, err2 = p.handler.DescribeSplitsEx(ctx, args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits_ex: " + err2.Error())
    oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("describe_splits_ex", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemAddColumnFamily struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemAddColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemAddColumnFamilyArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemAddColumnFamilyResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemAddColumnFamily(ctx, args.CfDef); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_column_family: " + err2.Error())
    oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_add_column_family", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemDropColumnFamily struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemDropColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemDropColumnFamilyArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemDropColumnFamilyResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemDropColumnFamily(ctx, args.ColumnFamily); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_column_family: " + err2.Error())
    oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_drop_column_family", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemAddKeyspace struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemAddKeyspace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemAddKeyspaceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemAddKeyspaceResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemAddKeyspace(ctx, args.KsDef); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_keyspace: " + err2.Error())
    oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_add_keyspace", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemDropKeyspace struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemDropKeyspace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemDropKeyspaceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemDropKeyspaceResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemDropKeyspace(ctx, args.Keyspace); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_keyspace: " + err2.Error())
    oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_drop_keyspace", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemUpdateKeyspace struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemUpdateKeyspace) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemUpdateKeyspaceArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemUpdateKeyspaceResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemUpdateKeyspace(ctx, args.KsDef); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_keyspace: " + err2.Error())
    oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_update_keyspace", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSystemUpdateColumnFamily struct {
  handler Cassandra
}

func (p *cassandraProcessorSystemUpdateColumnFamily) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSystemUpdateColumnFamilyArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSystemUpdateColumnFamilyResult{}
var retval string
  var err2 error
  if retval, err2 = p.handler.SystemUpdateColumnFamily(ctx, args.CfDef); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_column_family: " + err2.Error())
    oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = &retval
}
  if err2 = oprot.WriteMessageBegin("system_update_column_family", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorExecuteCqlQuery struct {
  handler Cassandra
}

func (p *cassandraProcessorExecuteCqlQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraExecuteCqlQueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraExecuteCqlQueryResult{}
var retval *CqlResult_
  var err2 error
  if retval, err2 = p.handler.ExecuteCqlQuery(ctx, args.Query, args.Compression); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql_query: " + err2.Error())
    oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("execute_cql_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorExecuteCql3Query struct {
  handler Cassandra
}

func (p *cassandraProcessorExecuteCql3Query) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraExecuteCql3QueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraExecuteCql3QueryResult{}
var retval *CqlResult_
  var err2 error
  if retval, err2 = p.handler.ExecuteCql3Query(ctx, args.Query, args.Compression, args.Consistency); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql3_query: " + err2.Error())
    oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("execute_cql3_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorPrepareCqlQuery struct {
  handler Cassandra
}

func (p *cassandraProcessorPrepareCqlQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraPrepareCqlQueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraPrepareCqlQueryResult{}
var retval *CqlPreparedResult_
  var err2 error
  if retval, err2 = p.handler.PrepareCqlQuery(ctx, args.Query, args.Compression); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql_query: " + err2.Error())
    oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("prepare_cql_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorPrepareCql3Query struct {
  handler Cassandra
}

func (p *cassandraProcessorPrepareCql3Query) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraPrepareCql3QueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraPrepareCql3QueryResult{}
var retval *CqlPreparedResult_
  var err2 error
  if retval, err2 = p.handler.PrepareCql3Query(ctx, args.Query, args.Compression); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql3_query: " + err2.Error())
    oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("prepare_cql3_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorExecutePreparedCqlQuery struct {
  handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCqlQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraExecutePreparedCqlQueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraExecutePreparedCqlQueryResult{}
var retval *CqlResult_
  var err2 error
  if retval, err2 = p.handler.ExecutePreparedCqlQuery(ctx, args.ItemId, args.Values); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql_query: " + err2.Error())
    oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorExecutePreparedCql3Query struct {
  handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCql3Query) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraExecutePreparedCql3QueryArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraExecutePreparedCql3QueryResult{}
var retval *CqlResult_
  var err2 error
  if retval, err2 = p.handler.ExecutePreparedCql3Query(ctx, args.ItemId, args.Values, args.Consistency); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    case *UnavailableException:
  result.Ue = v
    case *TimedOutException:
  result.Te = v
    case *SchemaDisagreementException:
  result.Sde = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql3_query: " + err2.Error())
    oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type cassandraProcessorSetCqlVersion struct {
  handler Cassandra
}

func (p *cassandraProcessorSetCqlVersion) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := CassandraSetCqlVersionArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := CassandraSetCqlVersionResult{}
  var err2 error
  if err2 = p.handler.SetCqlVersion(ctx, args.Version); err2 != nil {
  switch v := err2.(type) {
    case *InvalidRequestException:
  result.Ire = v
    default:
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cql_version: " + err2.Error())
    oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  }
  if err2 = oprot.WriteMessageBegin("set_cql_version", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - AuthRequest
type CassandraLoginArgs struct {
  AuthRequest *AuthenticationRequest `thrift:"auth_request,1,required" db:"auth_request" json:"auth_request"`
}

func NewCassandraLoginArgs() *CassandraLoginArgs {
  return &CassandraLoginArgs{}
}

var CassandraLoginArgs_AuthRequest_DEFAULT *AuthenticationRequest
func (p *CassandraLoginArgs) GetAuthRequest() *AuthenticationRequest {
  if !p.IsSetAuthRequest() {
    return CassandraLoginArgs_AuthRequest_DEFAULT
  }
return p.AuthRequest
}
func (p *CassandraLoginArgs) IsSetAuthRequest() bool {
  return p.AuthRequest != nil
}

func (p *CassandraLoginArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetAuthRequest bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetAuthRequest = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetAuthRequest{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field AuthRequest is not set"));
  }
  return nil
}

func (p *CassandraLoginArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.AuthRequest = &AuthenticationRequest{}
  if err := p.AuthRequest.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AuthRequest), err)
  }
  return nil
}

func (p *CassandraLoginArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("login_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraLoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("auth_request", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:auth_request: ", p), err) }
  if err := p.AuthRequest.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AuthRequest), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:auth_request: ", p), err) }
  return err
}

func (p *CassandraLoginArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraLoginArgs(%+v)", *p)
}

// Attributes:
//  - Authnx
//  - Authzx
type CassandraLoginResult struct {
  Authnx *AuthenticationException `thrift:"authnx,1" db:"authnx" json:"authnx,omitempty"`
  Authzx *AuthorizationException `thrift:"authzx,2" db:"authzx" json:"authzx,omitempty"`
}

func NewCassandraLoginResult() *CassandraLoginResult {
  return &CassandraLoginResult{}
}

var CassandraLoginResult_Authnx_DEFAULT *AuthenticationException
func (p *CassandraLoginResult) GetAuthnx() *AuthenticationException {
  if !p.IsSetAuthnx() {
    return CassandraLoginResult_Authnx_DEFAULT
  }
return p.Authnx
}
var CassandraLoginResult_Authzx_DEFAULT *AuthorizationException
func (p *CassandraLoginResult) GetAuthzx() *AuthorizationException {
  if !p.IsSetAuthzx() {
    return CassandraLoginResult_Authzx_DEFAULT
  }
return p.Authzx
}
func (p *CassandraLoginResult) IsSetAuthnx() bool {
  return p.Authnx != nil
}

func (p *CassandraLoginResult) IsSetAuthzx() bool {
  return p.Authzx != nil
}

func (p *CassandraLoginResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraLoginResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Authnx = &AuthenticationException{}
  if err := p.Authnx.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authnx), err)
  }
  return nil
}

func (p *CassandraLoginResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Authzx = &AuthorizationException{}
  if err := p.Authzx.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authzx), err)
  }
  return nil
}

func (p *CassandraLoginResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("login_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraLoginResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetAuthnx() {
    if err := oprot.WriteFieldBegin("authnx", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authnx: ", p), err) }
    if err := p.Authnx.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authnx), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authnx: ", p), err) }
  }
  return err
}

func (p *CassandraLoginResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetAuthzx() {
    if err := oprot.WriteFieldBegin("authzx", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:authzx: ", p), err) }
    if err := p.Authzx.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authzx), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:authzx: ", p), err) }
  }
  return err
}

func (p *CassandraLoginResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraLoginResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraSetKeyspaceArgs struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
}

func NewCassandraSetKeyspaceArgs() *CassandraSetKeyspaceArgs {
  return &CassandraSetKeyspaceArgs{}
}


func (p *CassandraSetKeyspaceArgs) GetKeyspace() string {
  return p.Keyspace
}
func (p *CassandraSetKeyspaceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  return nil
}

func (p *CassandraSetKeyspaceArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CassandraSetKeyspaceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("set_keyspace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSetKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CassandraSetKeyspaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSetKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Ire
type CassandraSetKeyspaceResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraSetKeyspaceResult() *CassandraSetKeyspaceResult {
  return &CassandraSetKeyspaceResult{}
}

var CassandraSetKeyspaceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSetKeyspaceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSetKeyspaceResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraSetKeyspaceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSetKeyspaceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSetKeyspaceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSetKeyspaceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("set_keyspace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSetKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSetKeyspaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSetKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
type CassandraGetArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnPath *ColumnPath `thrift:"column_path,2,required" db:"column_path" json:"column_path"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetArgs() *CassandraGetArgs {
  return &CassandraGetArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraGetArgs) GetKey() []byte {
  return p.Key
}
var CassandraGetArgs_ColumnPath_DEFAULT *ColumnPath
func (p *CassandraGetArgs) GetColumnPath() *ColumnPath {
  if !p.IsSetColumnPath() {
    return CassandraGetArgs_ColumnPath_DEFAULT
  }
return p.ColumnPath
}

func (p *CassandraGetArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetArgs) IsSetColumnPath() bool {
  return p.ColumnPath != nil
}

func (p *CassandraGetArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnPath bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnPath = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnPath{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPath is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraGetArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnPath = &ColumnPath{}
  if err := p.ColumnPath.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPath), err)
  }
  return nil
}

func (p *CassandraGetArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraGetArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_path: ", p), err) }
  if err := p.ColumnPath.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPath), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_path: ", p), err) }
  return err
}

func (p *CassandraGetArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Nfe
//  - Ue
//  - Te
type CassandraGetResult struct {
  Success *ColumnOrSuperColumn `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Nfe *NotFoundException `thrift:"nfe,2" db:"nfe" json:"nfe,omitempty"`
  Ue *UnavailableException `thrift:"ue,3" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,4" db:"te" json:"te,omitempty"`
}

func NewCassandraGetResult() *CassandraGetResult {
  return &CassandraGetResult{}
}

var CassandraGetResult_Success_DEFAULT *ColumnOrSuperColumn
func (p *CassandraGetResult) GetSuccess() *ColumnOrSuperColumn {
  if !p.IsSetSuccess() {
    return CassandraGetResult_Success_DEFAULT
  }
return p.Success
}
var CassandraGetResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetResult_Nfe_DEFAULT *NotFoundException
func (p *CassandraGetResult) GetNfe() *NotFoundException {
  if !p.IsSetNfe() {
    return CassandraGetResult_Nfe_DEFAULT
  }
return p.Nfe
}
var CassandraGetResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetResult) IsSetNfe() bool {
  return p.Nfe != nil
}

func (p *CassandraGetResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &ColumnOrSuperColumn{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraGetResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Nfe = &NotFoundException{}
  if err := p.Nfe.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Nfe), err)
  }
  return nil
}

func (p *CassandraGetResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetResult)  ReadField4(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetNfe() {
    if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:nfe: ", p), err) }
    if err := p.Nfe.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Nfe), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:nfe: ", p), err) }
  }
  return err
}

func (p *CassandraGetResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetResult) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraGetSliceArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Predicate *SlicePredicate `thrift:"predicate,3,required" db:"predicate" json:"predicate"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetSliceArgs() *CassandraGetSliceArgs {
  return &CassandraGetSliceArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraGetSliceArgs) GetKey() []byte {
  return p.Key
}
var CassandraGetSliceArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraGetSliceArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraGetSliceArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraGetSliceArgs_Predicate_DEFAULT *SlicePredicate
func (p *CassandraGetSliceArgs) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return CassandraGetSliceArgs_Predicate_DEFAULT
  }
return p.Predicate
}

func (p *CassandraGetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetSliceArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraGetSliceArgs) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *CassandraGetSliceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnParent bool = false;
  var issetPredicate bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPredicate = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetSliceArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraGetSliceArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraGetSliceArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *CassandraGetSliceArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetSliceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_slice_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraGetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraGetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err) }
  if err := p.Predicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err) }
  return err
}

func (p *CassandraGetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetSliceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetSliceResult struct {
  Success []*ColumnOrSuperColumn `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetSliceResult() *CassandraGetSliceResult {
  return &CassandraGetSliceResult{}
}

var CassandraGetSliceResult_Success_DEFAULT []*ColumnOrSuperColumn

func (p *CassandraGetSliceResult) GetSuccess() []*ColumnOrSuperColumn {
  return p.Success
}
var CassandraGetSliceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetSliceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetSliceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetSliceResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetSliceResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetSliceResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetSliceResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetSliceResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetSliceResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetSliceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetSliceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetSliceResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetSliceResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetSliceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetSliceResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ColumnOrSuperColumn, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem126 := &ColumnOrSuperColumn{}
    if err := _elem126.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem126), err)
    }
    p.Success = append(p.Success, _elem126)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraGetSliceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetSliceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetSliceResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetSliceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_slice_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetSliceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetSliceResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraGetCountArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Predicate *SlicePredicate `thrift:"predicate,3,required" db:"predicate" json:"predicate"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetCountArgs() *CassandraGetCountArgs {
  return &CassandraGetCountArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraGetCountArgs) GetKey() []byte {
  return p.Key
}
var CassandraGetCountArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraGetCountArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraGetCountArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraGetCountArgs_Predicate_DEFAULT *SlicePredicate
func (p *CassandraGetCountArgs) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return CassandraGetCountArgs_Predicate_DEFAULT
  }
return p.Predicate
}

func (p *CassandraGetCountArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetCountArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraGetCountArgs) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *CassandraGetCountArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnParent bool = false;
  var issetPredicate bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPredicate = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetCountArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraGetCountArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraGetCountArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *CassandraGetCountArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetCountArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_count_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraGetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraGetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err) }
  if err := p.Predicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err) }
  return err
}

func (p *CassandraGetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetCountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetCountArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetCountResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetCountResult() *CassandraGetCountResult {
  return &CassandraGetCountResult{}
}

var CassandraGetCountResult_Success_DEFAULT int32
func (p *CassandraGetCountResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return CassandraGetCountResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraGetCountResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetCountResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetCountResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetCountResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetCountResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetCountResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetCountResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetCountResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetCountResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetCountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetCountResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetCountResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetCountResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetCountResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetCountResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraGetCountResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetCountResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetCountResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetCountResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_count_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetCountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetCountResult(%+v)", *p)
}

// Attributes:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraMultigetSliceArgs struct {
  Keys [][]byte `thrift:"keys,1,required" db:"keys" json:"keys"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Predicate *SlicePredicate `thrift:"predicate,3,required" db:"predicate" json:"predicate"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraMultigetSliceArgs() *CassandraMultigetSliceArgs {
  return &CassandraMultigetSliceArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraMultigetSliceArgs) GetKeys() [][]byte {
  return p.Keys
}
var CassandraMultigetSliceArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraMultigetSliceArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraMultigetSliceArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraMultigetSliceArgs_Predicate_DEFAULT *SlicePredicate
func (p *CassandraMultigetSliceArgs) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return CassandraMultigetSliceArgs_Predicate_DEFAULT
  }
return p.Predicate
}

func (p *CassandraMultigetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraMultigetSliceArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraMultigetSliceArgs) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *CassandraMultigetSliceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeys bool = false;
  var issetColumnParent bool = false;
  var issetPredicate bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeys = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPredicate = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeys{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keys is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraMultigetSliceArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Keys =  tSlice
  for i := 0; i < size; i ++ {
var _elem127 []byte
    if v, err := iprot.ReadBinary(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem127 = v
}
    p.Keys = append(p.Keys, _elem127)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraMultigetSliceArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraMultigetSliceArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *CassandraMultigetSliceArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraMultigetSliceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("multiget_slice_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraMultigetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keys: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Keys {
    if err := oprot.WriteBinary(v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keys: ", p), err) }
  return err
}

func (p *CassandraMultigetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraMultigetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err) }
  if err := p.Predicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err) }
  return err
}

func (p *CassandraMultigetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraMultigetSliceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraMultigetSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraMultigetSliceResult struct {
  Success map[string][]*ColumnOrSuperColumn `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraMultigetSliceResult() *CassandraMultigetSliceResult {
  return &CassandraMultigetSliceResult{}
}

var CassandraMultigetSliceResult_Success_DEFAULT map[string][]*ColumnOrSuperColumn

func (p *CassandraMultigetSliceResult) GetSuccess() map[string][]*ColumnOrSuperColumn {
  return p.Success
}
var CassandraMultigetSliceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraMultigetSliceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraMultigetSliceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraMultigetSliceResult_Ue_DEFAULT *UnavailableException
func (p *CassandraMultigetSliceResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraMultigetSliceResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraMultigetSliceResult_Te_DEFAULT *TimedOutException
func (p *CassandraMultigetSliceResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraMultigetSliceResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraMultigetSliceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraMultigetSliceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraMultigetSliceResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraMultigetSliceResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraMultigetSliceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraMultigetSliceResult)  ReadField0(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]*ColumnOrSuperColumn, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key128 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key128 = v
}
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]*ColumnOrSuperColumn, 0, size)
    _val129 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem130 := &ColumnOrSuperColumn{}
      if err := _elem130.Read(iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem130), err)
      }
      _val129 = append(_val129, _elem130)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Success[_key128] = _val129
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraMultigetSliceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraMultigetSliceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraMultigetSliceResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraMultigetSliceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("multiget_slice_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraMultigetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
      }
      for _, v := range v {
        if err := v.Write(oprot); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
        }
      }
      if err := oprot.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
      }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetSliceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraMultigetSliceResult(%+v)", *p)
}

// Attributes:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraMultigetCountArgs struct {
  Keys [][]byte `thrift:"keys,1,required" db:"keys" json:"keys"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Predicate *SlicePredicate `thrift:"predicate,3,required" db:"predicate" json:"predicate"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraMultigetCountArgs() *CassandraMultigetCountArgs {
  return &CassandraMultigetCountArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraMultigetCountArgs) GetKeys() [][]byte {
  return p.Keys
}
var CassandraMultigetCountArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraMultigetCountArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraMultigetCountArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraMultigetCountArgs_Predicate_DEFAULT *SlicePredicate
func (p *CassandraMultigetCountArgs) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return CassandraMultigetCountArgs_Predicate_DEFAULT
  }
return p.Predicate
}

func (p *CassandraMultigetCountArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraMultigetCountArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraMultigetCountArgs) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *CassandraMultigetCountArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeys bool = false;
  var issetColumnParent bool = false;
  var issetPredicate bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeys = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPredicate = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeys{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keys is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraMultigetCountArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Keys =  tSlice
  for i := 0; i < size; i ++ {
var _elem131 []byte
    if v, err := iprot.ReadBinary(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem131 = v
}
    p.Keys = append(p.Keys, _elem131)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraMultigetCountArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraMultigetCountArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *CassandraMultigetCountArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraMultigetCountArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("multiget_count_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraMultigetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keys: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Keys {
    if err := oprot.WriteBinary(v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keys: ", p), err) }
  return err
}

func (p *CassandraMultigetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraMultigetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err) }
  if err := p.Predicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err) }
  return err
}

func (p *CassandraMultigetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraMultigetCountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraMultigetCountArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraMultigetCountResult struct {
  Success map[string]int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraMultigetCountResult() *CassandraMultigetCountResult {
  return &CassandraMultigetCountResult{}
}

var CassandraMultigetCountResult_Success_DEFAULT map[string]int32

func (p *CassandraMultigetCountResult) GetSuccess() map[string]int32 {
  return p.Success
}
var CassandraMultigetCountResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraMultigetCountResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraMultigetCountResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraMultigetCountResult_Ue_DEFAULT *UnavailableException
func (p *CassandraMultigetCountResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraMultigetCountResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraMultigetCountResult_Te_DEFAULT *TimedOutException
func (p *CassandraMultigetCountResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraMultigetCountResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraMultigetCountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraMultigetCountResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraMultigetCountResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraMultigetCountResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraMultigetCountResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraMultigetCountResult)  ReadField0(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]int32, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key132 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key132 = v
}
var _val133 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val133 = v
}
    p.Success[_key132] = _val133
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraMultigetCountResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraMultigetCountResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraMultigetCountResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraMultigetCountResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("multiget_count_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraMultigetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.I32, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraMultigetCountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraMultigetCountResult(%+v)", *p)
}

// Attributes:
//  - ColumnParent
//  - Predicate
//  - Range
//  - ConsistencyLevel
type CassandraGetRangeSlicesArgs struct {
  ColumnParent *ColumnParent `thrift:"column_parent,1,required" db:"column_parent" json:"column_parent"`
  Predicate *SlicePredicate `thrift:"predicate,2,required" db:"predicate" json:"predicate"`
  Range *KeyRange `thrift:"range,3,required" db:"range" json:"range"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetRangeSlicesArgs() *CassandraGetRangeSlicesArgs {
  return &CassandraGetRangeSlicesArgs{
ConsistencyLevel: 1,
}
}

var CassandraGetRangeSlicesArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraGetRangeSlicesArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraGetRangeSlicesArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraGetRangeSlicesArgs_Predicate_DEFAULT *SlicePredicate
func (p *CassandraGetRangeSlicesArgs) GetPredicate() *SlicePredicate {
  if !p.IsSetPredicate() {
    return CassandraGetRangeSlicesArgs_Predicate_DEFAULT
  }
return p.Predicate
}
var CassandraGetRangeSlicesArgs_Range_DEFAULT *KeyRange
func (p *CassandraGetRangeSlicesArgs) GetRange() *KeyRange {
  if !p.IsSetRange() {
    return CassandraGetRangeSlicesArgs_Range_DEFAULT
  }
return p.Range
}

func (p *CassandraGetRangeSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetRangeSlicesArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraGetRangeSlicesArgs) IsSetPredicate() bool {
  return p.Predicate != nil
}

func (p *CassandraGetRangeSlicesArgs) IsSetRange() bool {
  return p.Range != nil
}

func (p *CassandraGetRangeSlicesArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnParent bool = false;
  var issetPredicate bool = false;
  var issetRange bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPredicate = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetRange = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"));
  }
  if !issetRange{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Range is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetRangeSlicesArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.Predicate = &SlicePredicate{}
  if err := p.Predicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Range = &KeyRange{
  Count: 100,
}
  if err := p.Range.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Range), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetRangeSlicesArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_range_slices_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetRangeSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_parent: ", p), err) }
  return err
}

func (p *CassandraGetRangeSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:predicate: ", p), err) }
  if err := p.Predicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:predicate: ", p), err) }
  return err
}

func (p *CassandraGetRangeSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:range: ", p), err) }
  if err := p.Range.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Range), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:range: ", p), err) }
  return err
}

func (p *CassandraGetRangeSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetRangeSlicesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetRangeSlicesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetRangeSlicesResult struct {
  Success []*KeySlice `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetRangeSlicesResult() *CassandraGetRangeSlicesResult {
  return &CassandraGetRangeSlicesResult{}
}

var CassandraGetRangeSlicesResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetRangeSlicesResult) GetSuccess() []*KeySlice {
  return p.Success
}
var CassandraGetRangeSlicesResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetRangeSlicesResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetRangeSlicesResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetRangeSlicesResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetRangeSlicesResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetRangeSlicesResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetRangeSlicesResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetRangeSlicesResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetRangeSlicesResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetRangeSlicesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetRangeSlicesResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KeySlice, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem134 := &KeySlice{}
    if err := _elem134.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem134), err)
    }
    p.Success = append(p.Success, _elem134)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetRangeSlicesResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_range_slices_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetRangeSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetRangeSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetRangeSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetRangeSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetRangeSlicesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetRangeSlicesResult(%+v)", *p)
}

// Attributes:
//  - ColumnFamily
//  - Range
//  - StartColumn
//  - ConsistencyLevel
type CassandraGetPagedSliceArgs struct {
  ColumnFamily string `thrift:"column_family,1,required" db:"column_family" json:"column_family"`
  Range *KeyRange `thrift:"range,2,required" db:"range" json:"range"`
  StartColumn []byte `thrift:"start_column,3,required" db:"start_column" json:"start_column"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetPagedSliceArgs() *CassandraGetPagedSliceArgs {
  return &CassandraGetPagedSliceArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraGetPagedSliceArgs) GetColumnFamily() string {
  return p.ColumnFamily
}
var CassandraGetPagedSliceArgs_Range_DEFAULT *KeyRange
func (p *CassandraGetPagedSliceArgs) GetRange() *KeyRange {
  if !p.IsSetRange() {
    return CassandraGetPagedSliceArgs_Range_DEFAULT
  }
return p.Range
}

func (p *CassandraGetPagedSliceArgs) GetStartColumn() []byte {
  return p.StartColumn
}

func (p *CassandraGetPagedSliceArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetPagedSliceArgs) IsSetRange() bool {
  return p.Range != nil
}

func (p *CassandraGetPagedSliceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnFamily bool = false;
  var issetRange bool = false;
  var issetStartColumn bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnFamily = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetRange = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartColumn = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"));
  }
  if !issetRange{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Range is not set"));
  }
  if !issetStartColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartColumn is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetPagedSliceArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ColumnFamily = v
}
  return nil
}

func (p *CassandraGetPagedSliceArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.Range = &KeyRange{
  Count: 100,
}
  if err := p.Range.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Range), err)
  }
  return nil
}

func (p *CassandraGetPagedSliceArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.StartColumn = v
}
  return nil
}

func (p *CassandraGetPagedSliceArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetPagedSliceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_paged_slice_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetPagedSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_family: ", p), err) }
  if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_family (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_family: ", p), err) }
  return err
}

func (p *CassandraGetPagedSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range: ", p), err) }
  if err := p.Range.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Range), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range: ", p), err) }
  return err
}

func (p *CassandraGetPagedSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_column", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:start_column: ", p), err) }
  if err := oprot.WriteBinary(p.StartColumn); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_column (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:start_column: ", p), err) }
  return err
}

func (p *CassandraGetPagedSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetPagedSliceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetPagedSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetPagedSliceResult struct {
  Success []*KeySlice `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetPagedSliceResult() *CassandraGetPagedSliceResult {
  return &CassandraGetPagedSliceResult{}
}

var CassandraGetPagedSliceResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetPagedSliceResult) GetSuccess() []*KeySlice {
  return p.Success
}
var CassandraGetPagedSliceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetPagedSliceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetPagedSliceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetPagedSliceResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetPagedSliceResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetPagedSliceResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetPagedSliceResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetPagedSliceResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetPagedSliceResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetPagedSliceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetPagedSliceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetPagedSliceResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetPagedSliceResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetPagedSliceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetPagedSliceResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KeySlice, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem135 := &KeySlice{}
    if err := _elem135.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem135), err)
    }
    p.Success = append(p.Success, _elem135)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraGetPagedSliceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetPagedSliceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetPagedSliceResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetPagedSliceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_paged_slice_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetPagedSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetPagedSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetPagedSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetPagedSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetPagedSliceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetPagedSliceResult(%+v)", *p)
}

// Attributes:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
type CassandraGetIndexedSlicesArgs struct {
  ColumnParent *ColumnParent `thrift:"column_parent,1,required" db:"column_parent" json:"column_parent"`
  IndexClause *IndexClause `thrift:"index_clause,2,required" db:"index_clause" json:"index_clause"`
  ColumnPredicate *SlicePredicate `thrift:"column_predicate,3,required" db:"column_predicate" json:"column_predicate"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraGetIndexedSlicesArgs() *CassandraGetIndexedSlicesArgs {
  return &CassandraGetIndexedSlicesArgs{
ConsistencyLevel: 1,
}
}

var CassandraGetIndexedSlicesArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraGetIndexedSlicesArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraGetIndexedSlicesArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraGetIndexedSlicesArgs_IndexClause_DEFAULT *IndexClause
func (p *CassandraGetIndexedSlicesArgs) GetIndexClause() *IndexClause {
  if !p.IsSetIndexClause() {
    return CassandraGetIndexedSlicesArgs_IndexClause_DEFAULT
  }
return p.IndexClause
}
var CassandraGetIndexedSlicesArgs_ColumnPredicate_DEFAULT *SlicePredicate
func (p *CassandraGetIndexedSlicesArgs) GetColumnPredicate() *SlicePredicate {
  if !p.IsSetColumnPredicate() {
    return CassandraGetIndexedSlicesArgs_ColumnPredicate_DEFAULT
  }
return p.ColumnPredicate
}

func (p *CassandraGetIndexedSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraGetIndexedSlicesArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraGetIndexedSlicesArgs) IsSetIndexClause() bool {
  return p.IndexClause != nil
}

func (p *CassandraGetIndexedSlicesArgs) IsSetColumnPredicate() bool {
  return p.ColumnPredicate != nil
}

func (p *CassandraGetIndexedSlicesArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnParent bool = false;
  var issetIndexClause bool = false;
  var issetColumnPredicate bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetIndexClause = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnPredicate = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetIndexClause{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IndexClause is not set"));
  }
  if !issetColumnPredicate{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPredicate is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraGetIndexedSlicesArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.IndexClause = &IndexClause{
  Count: 100,
}
  if err := p.IndexClause.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.IndexClause), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.ColumnPredicate = &SlicePredicate{}
  if err := p.ColumnPredicate.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPredicate), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraGetIndexedSlicesArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_indexed_slices_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetIndexedSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_parent: ", p), err) }
  return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("index_clause", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:index_clause: ", p), err) }
  if err := p.IndexClause.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.IndexClause), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:index_clause: ", p), err) }
  return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_predicate", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_predicate: ", p), err) }
  if err := p.ColumnPredicate.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPredicate), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_predicate: ", p), err) }
  return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraGetIndexedSlicesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetIndexedSlicesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetIndexedSlicesResult struct {
  Success []*KeySlice `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetIndexedSlicesResult() *CassandraGetIndexedSlicesResult {
  return &CassandraGetIndexedSlicesResult{}
}

var CassandraGetIndexedSlicesResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetIndexedSlicesResult) GetSuccess() []*KeySlice {
  return p.Success
}
var CassandraGetIndexedSlicesResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetIndexedSlicesResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetIndexedSlicesResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetIndexedSlicesResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetIndexedSlicesResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetIndexedSlicesResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetIndexedSlicesResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetIndexedSlicesResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetIndexedSlicesResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetIndexedSlicesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetIndexedSlicesResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KeySlice, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem136 := &KeySlice{}
    if err := _elem136.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem136), err)
    }
    p.Success = append(p.Success, _elem136)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetIndexedSlicesResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_indexed_slices_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetIndexedSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetIndexedSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetIndexedSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetIndexedSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetIndexedSlicesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetIndexedSlicesResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
type CassandraInsertArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Column *Column `thrift:"column,3,required" db:"column" json:"column"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraInsertArgs() *CassandraInsertArgs {
  return &CassandraInsertArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraInsertArgs) GetKey() []byte {
  return p.Key
}
var CassandraInsertArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraInsertArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraInsertArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraInsertArgs_Column_DEFAULT *Column
func (p *CassandraInsertArgs) GetColumn() *Column {
  if !p.IsSetColumn() {
    return CassandraInsertArgs_Column_DEFAULT
  }
return p.Column
}

func (p *CassandraInsertArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraInsertArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraInsertArgs) IsSetColumn() bool {
  return p.Column != nil
}

func (p *CassandraInsertArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnParent bool = false;
  var issetColumn bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumn = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraInsertArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraInsertArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraInsertArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Column = &Column{}
  if err := p.Column.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
  }
  return nil
}

func (p *CassandraInsertArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraInsertArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("insert_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraInsertArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraInsertArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraInsertArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column: ", p), err) }
  if err := p.Column.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column: ", p), err) }
  return err
}

func (p *CassandraInsertArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraInsertArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraInsertArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraInsertResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraInsertResult() *CassandraInsertResult {
  return &CassandraInsertResult{}
}

var CassandraInsertResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraInsertResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraInsertResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraInsertResult_Ue_DEFAULT *UnavailableException
func (p *CassandraInsertResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraInsertResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraInsertResult_Te_DEFAULT *TimedOutException
func (p *CassandraInsertResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraInsertResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraInsertResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraInsertResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraInsertResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraInsertResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraInsertResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraInsertResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraInsertResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraInsertResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("insert_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraInsertResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraInsertResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraInsertResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraInsertResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraInsertResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
type CassandraAddArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnParent *ColumnParent `thrift:"column_parent,2,required" db:"column_parent" json:"column_parent"`
  Column *CounterColumn `thrift:"column,3,required" db:"column" json:"column"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraAddArgs() *CassandraAddArgs {
  return &CassandraAddArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraAddArgs) GetKey() []byte {
  return p.Key
}
var CassandraAddArgs_ColumnParent_DEFAULT *ColumnParent
func (p *CassandraAddArgs) GetColumnParent() *ColumnParent {
  if !p.IsSetColumnParent() {
    return CassandraAddArgs_ColumnParent_DEFAULT
  }
return p.ColumnParent
}
var CassandraAddArgs_Column_DEFAULT *CounterColumn
func (p *CassandraAddArgs) GetColumn() *CounterColumn {
  if !p.IsSetColumn() {
    return CassandraAddArgs_Column_DEFAULT
  }
return p.Column
}

func (p *CassandraAddArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraAddArgs) IsSetColumnParent() bool {
  return p.ColumnParent != nil
}

func (p *CassandraAddArgs) IsSetColumn() bool {
  return p.Column != nil
}

func (p *CassandraAddArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnParent bool = false;
  var issetColumn bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnParent = true
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumn = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnParent{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"));
  }
  if !issetColumn{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraAddArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraAddArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnParent = &ColumnParent{}
  if err := p.ColumnParent.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
  }
  return nil
}

func (p *CassandraAddArgs)  ReadField3(iprot thrift.TProtocol) error {
  p.Column = &CounterColumn{}
  if err := p.Column.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
  }
  return nil
}

func (p *CassandraAddArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraAddArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("add_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraAddArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraAddArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err) }
  if err := p.ColumnParent.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err) }
  return err
}

func (p *CassandraAddArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column: ", p), err) }
  if err := p.Column.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column: ", p), err) }
  return err
}

func (p *CassandraAddArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraAddArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraAddArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraAddResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraAddResult() *CassandraAddResult {
  return &CassandraAddResult{}
}

var CassandraAddResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraAddResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraAddResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraAddResult_Ue_DEFAULT *UnavailableException
func (p *CassandraAddResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraAddResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraAddResult_Te_DEFAULT *TimedOutException
func (p *CassandraAddResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraAddResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraAddResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraAddResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraAddResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraAddResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraAddResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraAddResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraAddResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraAddResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("add_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraAddResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraAddResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraAddResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraAddResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraAddResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnFamily
//  - Expected
//  - Updates
//  - SerialConsistencyLevel
//  - CommitConsistencyLevel
type CassandraCasArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnFamily string `thrift:"column_family,2,required" db:"column_family" json:"column_family"`
  Expected []*Column `thrift:"expected,3" db:"expected" json:"expected"`
  Updates []*Column `thrift:"updates,4" db:"updates" json:"updates"`
  SerialConsistencyLevel ConsistencyLevel `thrift:"serial_consistency_level,5,required" db:"serial_consistency_level" json:"serial_consistency_level"`
  CommitConsistencyLevel ConsistencyLevel `thrift:"commit_consistency_level,6,required" db:"commit_consistency_level" json:"commit_consistency_level"`
}

func NewCassandraCasArgs() *CassandraCasArgs {
  return &CassandraCasArgs{
SerialConsistencyLevel: 9,

CommitConsistencyLevel: 2,
}
}


func (p *CassandraCasArgs) GetKey() []byte {
  return p.Key
}

func (p *CassandraCasArgs) GetColumnFamily() string {
  return p.ColumnFamily
}

func (p *CassandraCasArgs) GetExpected() []*Column {
  return p.Expected
}

func (p *CassandraCasArgs) GetUpdates() []*Column {
  return p.Updates
}

func (p *CassandraCasArgs) GetSerialConsistencyLevel() ConsistencyLevel {
  return p.SerialConsistencyLevel
}

func (p *CassandraCasArgs) GetCommitConsistencyLevel() ConsistencyLevel {
  return p.CommitConsistencyLevel
}
func (p *CassandraCasArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnFamily bool = false;
  var issetSerialConsistencyLevel bool = false;
  var issetCommitConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnFamily = true
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetSerialConsistencyLevel = true
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCommitConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"));
  }
  if !issetSerialConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SerialConsistencyLevel is not set"));
  }
  if !issetCommitConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CommitConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraCasArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraCasArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ColumnFamily = v
}
  return nil
}

func (p *CassandraCasArgs)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Column, 0, size)
  p.Expected =  tSlice
  for i := 0; i < size; i ++ {
    _elem137 := &Column{}
    if err := _elem137.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem137), err)
    }
    p.Expected = append(p.Expected, _elem137)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraCasArgs)  ReadField4(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Column, 0, size)
  p.Updates =  tSlice
  for i := 0; i < size; i ++ {
    _elem138 := &Column{}
    if err := _elem138.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem138), err)
    }
    p.Updates = append(p.Updates, _elem138)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraCasArgs)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.SerialConsistencyLevel = temp
}
  return nil
}

func (p *CassandraCasArgs)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.CommitConsistencyLevel = temp
}
  return nil
}

func (p *CassandraCasArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("cas_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraCasArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraCasArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_family: ", p), err) }
  if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_family (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_family: ", p), err) }
  return err
}

func (p *CassandraCasArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("expected", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:expected: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expected)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Expected {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:expected: ", p), err) }
  return err
}

func (p *CassandraCasArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("updates", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:updates: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Updates)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Updates {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:updates: ", p), err) }
  return err
}

func (p *CassandraCasArgs) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("serial_consistency_level", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:serial_consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.SerialConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serial_consistency_level (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:serial_consistency_level: ", p), err) }
  return err
}

func (p *CassandraCasArgs) writeField6(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("commit_consistency_level", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:commit_consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.CommitConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.commit_consistency_level (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:commit_consistency_level: ", p), err) }
  return err
}

func (p *CassandraCasArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraCasArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraCasResult struct {
  Success *CASResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraCasResult() *CassandraCasResult {
  return &CassandraCasResult{}
}

var CassandraCasResult_Success_DEFAULT *CASResult_
func (p *CassandraCasResult) GetSuccess() *CASResult_ {
  if !p.IsSetSuccess() {
    return CassandraCasResult_Success_DEFAULT
  }
return p.Success
}
var CassandraCasResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraCasResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraCasResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraCasResult_Ue_DEFAULT *UnavailableException
func (p *CassandraCasResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraCasResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraCasResult_Te_DEFAULT *TimedOutException
func (p *CassandraCasResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraCasResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraCasResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraCasResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraCasResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraCasResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraCasResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraCasResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CASResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraCasResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraCasResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraCasResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraCasResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("cas_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraCasResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraCasResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraCasResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraCasResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraCasResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraCasResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
type CassandraRemoveArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  ColumnPath *ColumnPath `thrift:"column_path,2,required" db:"column_path" json:"column_path"`
  Timestamp int64 `thrift:"timestamp,3,required" db:"timestamp" json:"timestamp"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraRemoveArgs() *CassandraRemoveArgs {
  return &CassandraRemoveArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraRemoveArgs) GetKey() []byte {
  return p.Key
}
var CassandraRemoveArgs_ColumnPath_DEFAULT *ColumnPath
func (p *CassandraRemoveArgs) GetColumnPath() *ColumnPath {
  if !p.IsSetColumnPath() {
    return CassandraRemoveArgs_ColumnPath_DEFAULT
  }
return p.ColumnPath
}

func (p *CassandraRemoveArgs) GetTimestamp() int64 {
  return p.Timestamp
}

func (p *CassandraRemoveArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraRemoveArgs) IsSetColumnPath() bool {
  return p.ColumnPath != nil
}

func (p *CassandraRemoveArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetColumnPath bool = false;
  var issetTimestamp bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnPath = true
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetTimestamp = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetColumnPath{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPath is not set"));
  }
  if !issetTimestamp{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Timestamp is not set"));
  }
  return nil
}

func (p *CassandraRemoveArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraRemoveArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.ColumnPath = &ColumnPath{}
  if err := p.ColumnPath.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPath), err)
  }
  return nil
}

func (p *CassandraRemoveArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Timestamp = v
}
  return nil
}

func (p *CassandraRemoveArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraRemoveArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("remove_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraRemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraRemoveArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_path: ", p), err) }
  if err := p.ColumnPath.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPath), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_path: ", p), err) }
  return err
}

func (p *CassandraRemoveArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err) }
  if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err) }
  return err
}

func (p *CassandraRemoveArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err) }
  return err
}

func (p *CassandraRemoveArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraRemoveArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraRemoveResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraRemoveResult() *CassandraRemoveResult {
  return &CassandraRemoveResult{}
}

var CassandraRemoveResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraRemoveResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraRemoveResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraRemoveResult_Ue_DEFAULT *UnavailableException
func (p *CassandraRemoveResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraRemoveResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraRemoveResult_Te_DEFAULT *TimedOutException
func (p *CassandraRemoveResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraRemoveResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraRemoveResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraRemoveResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraRemoveResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraRemoveResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraRemoveResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraRemoveResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraRemoveResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraRemoveResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("remove_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraRemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraRemoveResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - Path
//  - ConsistencyLevel
type CassandraRemoveCounterArgs struct {
  Key []byte `thrift:"key,1,required" db:"key" json:"key"`
  Path *ColumnPath `thrift:"path,2,required" db:"path" json:"path"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraRemoveCounterArgs() *CassandraRemoveCounterArgs {
  return &CassandraRemoveCounterArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraRemoveCounterArgs) GetKey() []byte {
  return p.Key
}
var CassandraRemoveCounterArgs_Path_DEFAULT *ColumnPath
func (p *CassandraRemoveCounterArgs) GetPath() *ColumnPath {
  if !p.IsSetPath() {
    return CassandraRemoveCounterArgs_Path_DEFAULT
  }
return p.Path
}

func (p *CassandraRemoveCounterArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraRemoveCounterArgs) IsSetPath() bool {
  return p.Path != nil
}

func (p *CassandraRemoveCounterArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKey bool = false;
  var issetPath bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKey = true
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetPath = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKey{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"));
  }
  if !issetPath{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Path is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraRemoveCounterArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *CassandraRemoveCounterArgs)  ReadField2(iprot thrift.TProtocol) error {
  p.Path = &ColumnPath{}
  if err := p.Path.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Path), err)
  }
  return nil
}

func (p *CassandraRemoveCounterArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraRemoveCounterArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("remove_counter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraRemoveCounterArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *CassandraRemoveCounterArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("path", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:path: ", p), err) }
  if err := p.Path.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Path), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:path: ", p), err) }
  return err
}

func (p *CassandraRemoveCounterArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency_level: ", p), err) }
  return err
}

func (p *CassandraRemoveCounterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraRemoveCounterArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraRemoveCounterResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraRemoveCounterResult() *CassandraRemoveCounterResult {
  return &CassandraRemoveCounterResult{}
}

var CassandraRemoveCounterResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraRemoveCounterResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraRemoveCounterResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraRemoveCounterResult_Ue_DEFAULT *UnavailableException
func (p *CassandraRemoveCounterResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraRemoveCounterResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraRemoveCounterResult_Te_DEFAULT *TimedOutException
func (p *CassandraRemoveCounterResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraRemoveCounterResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraRemoveCounterResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraRemoveCounterResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraRemoveCounterResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraRemoveCounterResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraRemoveCounterResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraRemoveCounterResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraRemoveCounterResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraRemoveCounterResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("remove_counter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraRemoveCounterResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveCounterResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveCounterResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraRemoveCounterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraRemoveCounterResult(%+v)", *p)
}

// Attributes:
//  - MutationMap
//  - ConsistencyLevel
type CassandraBatchMutateArgs struct {
  MutationMap map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" db:"mutation_map" json:"mutation_map"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,2,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraBatchMutateArgs() *CassandraBatchMutateArgs {
  return &CassandraBatchMutateArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraBatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
  return p.MutationMap
}

func (p *CassandraBatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraBatchMutateArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetMutationMap bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetMutationMap = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetMutationMap{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MutationMap is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraBatchMutateArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]map[string][]*Mutation, size)
  p.MutationMap =  tMap
  for i := 0; i < size; i ++ {
var _key139 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key139 = v
}
    _, _, size, err := iprot.ReadMapBegin()
    if err != nil {
      return thrift.PrependError("error reading map begin: ", err)
    }
    tMap := make(map[string][]*Mutation, size)
    _val140 :=  tMap
    for i := 0; i < size; i ++ {
var _key141 string
      if v, err := iprot.ReadString(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _key141 = v
}
      _, size, err := iprot.ReadListBegin()
      if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
      }
      tSlice := make([]*Mutation, 0, size)
      _val142 :=  tSlice
      for i := 0; i < size; i ++ {
        _elem143 := &Mutation{}
        if err := _elem143.Read(iprot); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem143), err)
        }
        _val142 = append(_val142, _elem143)
      }
      if err := iprot.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
      }
      _val140[_key141] = _val142
    }
    if err := iprot.ReadMapEnd(); err != nil {
      return thrift.PrependError("error reading map end: ", err)
    }
    p.MutationMap[_key139] = _val140
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraBatchMutateArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraBatchMutateArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("batch_mutate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:mutation_map: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.MutationMap {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range v {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
      }
      for _, v := range v {
        if err := v.Write(oprot); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
        }
      }
      if err := oprot.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
      }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:mutation_map: ", p), err) }
  return err
}

func (p *CassandraBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:consistency_level: ", p), err) }
  return err
}

func (p *CassandraBatchMutateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraBatchMutateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraBatchMutateResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraBatchMutateResult() *CassandraBatchMutateResult {
  return &CassandraBatchMutateResult{}
}

var CassandraBatchMutateResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraBatchMutateResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraBatchMutateResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraBatchMutateResult_Ue_DEFAULT *UnavailableException
func (p *CassandraBatchMutateResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraBatchMutateResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraBatchMutateResult_Te_DEFAULT *TimedOutException
func (p *CassandraBatchMutateResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraBatchMutateResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraBatchMutateResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraBatchMutateResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraBatchMutateResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraBatchMutateResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraBatchMutateResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraBatchMutateResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraBatchMutateResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraBatchMutateResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("batch_mutate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraBatchMutateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraBatchMutateResult(%+v)", *p)
}

// Attributes:
//  - MutationMap
//  - ConsistencyLevel
type CassandraAtomicBatchMutateArgs struct {
  MutationMap map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" db:"mutation_map" json:"mutation_map"`
  ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,2,required" db:"consistency_level" json:"consistency_level"`
}

func NewCassandraAtomicBatchMutateArgs() *CassandraAtomicBatchMutateArgs {
  return &CassandraAtomicBatchMutateArgs{
ConsistencyLevel: 1,
}
}


func (p *CassandraAtomicBatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
  return p.MutationMap
}

func (p *CassandraAtomicBatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
  return p.ConsistencyLevel
}
func (p *CassandraAtomicBatchMutateArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetMutationMap bool = false;
  var issetConsistencyLevel bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetMutationMap = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistencyLevel = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetMutationMap{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MutationMap is not set"));
  }
  if !issetConsistencyLevel{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"));
  }
  return nil
}

func (p *CassandraAtomicBatchMutateArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]map[string][]*Mutation, size)
  p.MutationMap =  tMap
  for i := 0; i < size; i ++ {
var _key144 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key144 = v
}
    _, _, size, err := iprot.ReadMapBegin()
    if err != nil {
      return thrift.PrependError("error reading map begin: ", err)
    }
    tMap := make(map[string][]*Mutation, size)
    _val145 :=  tMap
    for i := 0; i < size; i ++ {
var _key146 string
      if v, err := iprot.ReadString(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _key146 = v
}
      _, size, err := iprot.ReadListBegin()
      if err != nil {
        return thrift.PrependError("error reading list begin: ", err)
      }
      tSlice := make([]*Mutation, 0, size)
      _val147 :=  tSlice
      for i := 0; i < size; i ++ {
        _elem148 := &Mutation{}
        if err := _elem148.Read(iprot); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem148), err)
        }
        _val147 = append(_val147, _elem148)
      }
      if err := iprot.ReadListEnd(); err != nil {
        return thrift.PrependError("error reading list end: ", err)
      }
      _val145[_key146] = _val147
    }
    if err := iprot.ReadMapEnd(); err != nil {
      return thrift.PrependError("error reading map end: ", err)
    }
    p.MutationMap[_key144] = _val145
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraAtomicBatchMutateArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.ConsistencyLevel = temp
}
  return nil
}

func (p *CassandraAtomicBatchMutateArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("atomic_batch_mutate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraAtomicBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:mutation_map: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.MutationMap {
    if err := oprot.WriteString(string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range v {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
      }
      for _, v := range v {
        if err := v.Write(oprot); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
        }
      }
      if err := oprot.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
      }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:mutation_map: ", p), err) }
  return err
}

func (p *CassandraAtomicBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:consistency_level: ", p), err) }
  if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency_level (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:consistency_level: ", p), err) }
  return err
}

func (p *CassandraAtomicBatchMutateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraAtomicBatchMutateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraAtomicBatchMutateResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraAtomicBatchMutateResult() *CassandraAtomicBatchMutateResult {
  return &CassandraAtomicBatchMutateResult{}
}

var CassandraAtomicBatchMutateResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraAtomicBatchMutateResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraAtomicBatchMutateResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraAtomicBatchMutateResult_Ue_DEFAULT *UnavailableException
func (p *CassandraAtomicBatchMutateResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraAtomicBatchMutateResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraAtomicBatchMutateResult_Te_DEFAULT *TimedOutException
func (p *CassandraAtomicBatchMutateResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraAtomicBatchMutateResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraAtomicBatchMutateResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraAtomicBatchMutateResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraAtomicBatchMutateResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraAtomicBatchMutateResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraAtomicBatchMutateResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraAtomicBatchMutateResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraAtomicBatchMutateResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraAtomicBatchMutateResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("atomic_batch_mutate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraAtomicBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraAtomicBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraAtomicBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraAtomicBatchMutateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraAtomicBatchMutateResult(%+v)", *p)
}

// Attributes:
//  - Cfname
type CassandraTruncateArgs struct {
  Cfname string `thrift:"cfname,1,required" db:"cfname" json:"cfname"`
}

func NewCassandraTruncateArgs() *CassandraTruncateArgs {
  return &CassandraTruncateArgs{}
}


func (p *CassandraTruncateArgs) GetCfname() string {
  return p.Cfname
}
func (p *CassandraTruncateArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCfname bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfname = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCfname{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Cfname is not set"));
  }
  return nil
}

func (p *CassandraTruncateArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cfname = v
}
  return nil
}

func (p *CassandraTruncateArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("truncate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraTruncateArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cfname", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfname: ", p), err) }
  if err := oprot.WriteString(string(p.Cfname)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cfname (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfname: ", p), err) }
  return err
}

func (p *CassandraTruncateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraTruncateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraTruncateResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraTruncateResult() *CassandraTruncateResult {
  return &CassandraTruncateResult{}
}

var CassandraTruncateResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraTruncateResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraTruncateResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraTruncateResult_Ue_DEFAULT *UnavailableException
func (p *CassandraTruncateResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraTruncateResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraTruncateResult_Te_DEFAULT *TimedOutException
func (p *CassandraTruncateResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraTruncateResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraTruncateResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraTruncateResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraTruncateResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraTruncateResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraTruncateResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraTruncateResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraTruncateResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraTruncateResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("truncate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraTruncateResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraTruncateResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraTruncateResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraTruncateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraTruncateResult(%+v)", *p)
}

// Attributes:
//  - Request
type CassandraGetMultiSliceArgs struct {
  Request *MultiSliceRequest `thrift:"request,1,required" db:"request" json:"request"`
}

func NewCassandraGetMultiSliceArgs() *CassandraGetMultiSliceArgs {
  return &CassandraGetMultiSliceArgs{}
}

var CassandraGetMultiSliceArgs_Request_DEFAULT *MultiSliceRequest
func (p *CassandraGetMultiSliceArgs) GetRequest() *MultiSliceRequest {
  if !p.IsSetRequest() {
    return CassandraGetMultiSliceArgs_Request_DEFAULT
  }
return p.Request
}
func (p *CassandraGetMultiSliceArgs) IsSetRequest() bool {
  return p.Request != nil
}

func (p *CassandraGetMultiSliceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetRequest bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetRequest = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetRequest{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Request is not set"));
  }
  return nil
}

func (p *CassandraGetMultiSliceArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.Request = &MultiSliceRequest{
  Count: 1000,

  ConsistencyLevel:   1,
}
  if err := p.Request.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
  }
  return nil
}

func (p *CassandraGetMultiSliceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_multi_slice_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetMultiSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err) }
  if err := p.Request.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err) }
  return err
}

func (p *CassandraGetMultiSliceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetMultiSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetMultiSliceResult struct {
  Success []*ColumnOrSuperColumn `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
}

func NewCassandraGetMultiSliceResult() *CassandraGetMultiSliceResult {
  return &CassandraGetMultiSliceResult{}
}

var CassandraGetMultiSliceResult_Success_DEFAULT []*ColumnOrSuperColumn

func (p *CassandraGetMultiSliceResult) GetSuccess() []*ColumnOrSuperColumn {
  return p.Success
}
var CassandraGetMultiSliceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraGetMultiSliceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraGetMultiSliceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraGetMultiSliceResult_Ue_DEFAULT *UnavailableException
func (p *CassandraGetMultiSliceResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraGetMultiSliceResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraGetMultiSliceResult_Te_DEFAULT *TimedOutException
func (p *CassandraGetMultiSliceResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraGetMultiSliceResult_Te_DEFAULT
  }
return p.Te
}
func (p *CassandraGetMultiSliceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraGetMultiSliceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraGetMultiSliceResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraGetMultiSliceResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraGetMultiSliceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraGetMultiSliceResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ColumnOrSuperColumn, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem149 := &ColumnOrSuperColumn{}
    if err := _elem149.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem149), err)
    }
    p.Success = append(p.Success, _elem149)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraGetMultiSliceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraGetMultiSliceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraGetMultiSliceResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraGetMultiSliceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("get_multi_slice_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraGetMultiSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraGetMultiSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraGetMultiSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraGetMultiSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraGetMultiSliceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraGetMultiSliceResult(%+v)", *p)
}

type CassandraDescribeSchemaVersionsArgs struct {
}

func NewCassandraDescribeSchemaVersionsArgs() *CassandraDescribeSchemaVersionsArgs {
  return &CassandraDescribeSchemaVersionsArgs{}
}

func (p *CassandraDescribeSchemaVersionsArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSchemaVersionsArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_schema_versions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSchemaVersionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSchemaVersionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSchemaVersionsResult struct {
  Success map[string][]string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeSchemaVersionsResult() *CassandraDescribeSchemaVersionsResult {
  return &CassandraDescribeSchemaVersionsResult{}
}

var CassandraDescribeSchemaVersionsResult_Success_DEFAULT map[string][]string

func (p *CassandraDescribeSchemaVersionsResult) GetSuccess() map[string][]string {
  return p.Success
}
var CassandraDescribeSchemaVersionsResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeSchemaVersionsResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeSchemaVersionsResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeSchemaVersionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeSchemaVersionsResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeSchemaVersionsResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSchemaVersionsResult)  ReadField0(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string][]string, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key150 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key150 = v
}
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]string, 0, size)
    _val151 :=  tSlice
    for i := 0; i < size; i ++ {
var _elem152 string
      if v, err := iprot.ReadString(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem152 = v
}
      _val151 = append(_val151, _elem152)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Success[_key150] = _val151
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraDescribeSchemaVersionsResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeSchemaVersionsResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_schema_versions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSchemaVersionsResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
        return thrift.PrependError("error writing list begin: ", err)
      }
      for _, v := range v {
        if err := oprot.WriteString(string(v)); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      }
      if err := oprot.WriteListEnd(); err != nil {
        return thrift.PrependError("error writing list end: ", err)
      }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSchemaVersionsResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSchemaVersionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSchemaVersionsResult(%+v)", *p)
}

type CassandraDescribeKeyspacesArgs struct {
}

func NewCassandraDescribeKeyspacesArgs() *CassandraDescribeKeyspacesArgs {
  return &CassandraDescribeKeyspacesArgs{}
}

func (p *CassandraDescribeKeyspacesArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspacesArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_keyspaces_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeKeyspacesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeKeyspacesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeKeyspacesResult struct {
  Success []*KsDef `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeKeyspacesResult() *CassandraDescribeKeyspacesResult {
  return &CassandraDescribeKeyspacesResult{}
}

var CassandraDescribeKeyspacesResult_Success_DEFAULT []*KsDef

func (p *CassandraDescribeKeyspacesResult) GetSuccess() []*KsDef {
  return p.Success
}
var CassandraDescribeKeyspacesResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeKeyspacesResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeKeyspacesResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeKeyspacesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeKeyspacesResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeKeyspacesResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspacesResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KsDef, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem153 := &KsDef{
    DurableWrites: true,
}
    if err := _elem153.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem153), err)
    }
    p.Success = append(p.Success, _elem153)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraDescribeKeyspacesResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspacesResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_keyspaces_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeKeyspacesResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeKeyspacesResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeKeyspacesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeKeyspacesResult(%+v)", *p)
}

type CassandraDescribeClusterNameArgs struct {
}

func NewCassandraDescribeClusterNameArgs() *CassandraDescribeClusterNameArgs {
  return &CassandraDescribeClusterNameArgs{}
}

func (p *CassandraDescribeClusterNameArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeClusterNameArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_cluster_name_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeClusterNameArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeClusterNameArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeClusterNameResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewCassandraDescribeClusterNameResult() *CassandraDescribeClusterNameResult {
  return &CassandraDescribeClusterNameResult{}
}

var CassandraDescribeClusterNameResult_Success_DEFAULT string
func (p *CassandraDescribeClusterNameResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraDescribeClusterNameResult_Success_DEFAULT
  }
return *p.Success
}
func (p *CassandraDescribeClusterNameResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeClusterNameResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeClusterNameResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraDescribeClusterNameResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_cluster_name_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeClusterNameResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeClusterNameResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeClusterNameResult(%+v)", *p)
}

type CassandraDescribeVersionArgs struct {
}

func NewCassandraDescribeVersionArgs() *CassandraDescribeVersionArgs {
  return &CassandraDescribeVersionArgs{}
}

func (p *CassandraDescribeVersionArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeVersionArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_version_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeVersionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeVersionResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewCassandraDescribeVersionResult() *CassandraDescribeVersionResult {
  return &CassandraDescribeVersionResult{}
}

var CassandraDescribeVersionResult_Success_DEFAULT string
func (p *CassandraDescribeVersionResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraDescribeVersionResult_Success_DEFAULT
  }
return *p.Success
}
func (p *CassandraDescribeVersionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeVersionResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeVersionResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraDescribeVersionResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_version_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeVersionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeVersionResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeRingArgs struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
}

func NewCassandraDescribeRingArgs() *CassandraDescribeRingArgs {
  return &CassandraDescribeRingArgs{}
}


func (p *CassandraDescribeRingArgs) GetKeyspace() string {
  return p.Keyspace
}
func (p *CassandraDescribeRingArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  return nil
}

func (p *CassandraDescribeRingArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CassandraDescribeRingArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_ring_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CassandraDescribeRingArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeRingArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeRingResult struct {
  Success []*TokenRange `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeRingResult() *CassandraDescribeRingResult {
  return &CassandraDescribeRingResult{}
}

var CassandraDescribeRingResult_Success_DEFAULT []*TokenRange

func (p *CassandraDescribeRingResult) GetSuccess() []*TokenRange {
  return p.Success
}
var CassandraDescribeRingResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeRingResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeRingResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeRingResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeRingResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeRingResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeRingResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TokenRange, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem154 := &TokenRange{}
    if err := _elem154.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem154), err)
    }
    p.Success = append(p.Success, _elem154)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraDescribeRingResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeRingResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_ring_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeRingResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeRingResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeRingResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeRingResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeLocalRingArgs struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
}

func NewCassandraDescribeLocalRingArgs() *CassandraDescribeLocalRingArgs {
  return &CassandraDescribeLocalRingArgs{}
}


func (p *CassandraDescribeLocalRingArgs) GetKeyspace() string {
  return p.Keyspace
}
func (p *CassandraDescribeLocalRingArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  return nil
}

func (p *CassandraDescribeLocalRingArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CassandraDescribeLocalRingArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_local_ring_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeLocalRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CassandraDescribeLocalRingArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeLocalRingArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeLocalRingResult struct {
  Success []*TokenRange `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeLocalRingResult() *CassandraDescribeLocalRingResult {
  return &CassandraDescribeLocalRingResult{}
}

var CassandraDescribeLocalRingResult_Success_DEFAULT []*TokenRange

func (p *CassandraDescribeLocalRingResult) GetSuccess() []*TokenRange {
  return p.Success
}
var CassandraDescribeLocalRingResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeLocalRingResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeLocalRingResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeLocalRingResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeLocalRingResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeLocalRingResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeLocalRingResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TokenRange, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem155 := &TokenRange{}
    if err := _elem155.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem155), err)
    }
    p.Success = append(p.Success, _elem155)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraDescribeLocalRingResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeLocalRingResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_local_ring_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeLocalRingResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeLocalRingResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeLocalRingResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeLocalRingResult(%+v)", *p)
}

type CassandraDescribeTokenMapArgs struct {
}

func NewCassandraDescribeTokenMapArgs() *CassandraDescribeTokenMapArgs {
  return &CassandraDescribeTokenMapArgs{}
}

func (p *CassandraDescribeTokenMapArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeTokenMapArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_token_map_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeTokenMapArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeTokenMapArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeTokenMapResult struct {
  Success map[string]string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeTokenMapResult() *CassandraDescribeTokenMapResult {
  return &CassandraDescribeTokenMapResult{}
}

var CassandraDescribeTokenMapResult_Success_DEFAULT map[string]string

func (p *CassandraDescribeTokenMapResult) GetSuccess() map[string]string {
  return p.Success
}
var CassandraDescribeTokenMapResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeTokenMapResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeTokenMapResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeTokenMapResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeTokenMapResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeTokenMapResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeTokenMapResult)  ReadField0(iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key156 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key156 = v
}
var _val157 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val157 = v
}
    p.Success[_key156] = _val157
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CassandraDescribeTokenMapResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeTokenMapResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_token_map_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeTokenMapResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeTokenMapResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeTokenMapResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeTokenMapResult(%+v)", *p)
}

type CassandraDescribePartitionerArgs struct {
}

func NewCassandraDescribePartitionerArgs() *CassandraDescribePartitionerArgs {
  return &CassandraDescribePartitionerArgs{}
}

func (p *CassandraDescribePartitionerArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribePartitionerArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_partitioner_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribePartitionerArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribePartitionerArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribePartitionerResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewCassandraDescribePartitionerResult() *CassandraDescribePartitionerResult {
  return &CassandraDescribePartitionerResult{}
}

var CassandraDescribePartitionerResult_Success_DEFAULT string
func (p *CassandraDescribePartitionerResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraDescribePartitionerResult_Success_DEFAULT
  }
return *p.Success
}
func (p *CassandraDescribePartitionerResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribePartitionerResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribePartitionerResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraDescribePartitionerResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_partitioner_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribePartitionerResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribePartitionerResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribePartitionerResult(%+v)", *p)
}

type CassandraDescribeSnitchArgs struct {
}

func NewCassandraDescribeSnitchArgs() *CassandraDescribeSnitchArgs {
  return &CassandraDescribeSnitchArgs{}
}

func (p *CassandraDescribeSnitchArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSnitchArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_snitch_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSnitchArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSnitchArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeSnitchResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewCassandraDescribeSnitchResult() *CassandraDescribeSnitchResult {
  return &CassandraDescribeSnitchResult{}
}

var CassandraDescribeSnitchResult_Success_DEFAULT string
func (p *CassandraDescribeSnitchResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraDescribeSnitchResult_Success_DEFAULT
  }
return *p.Success
}
func (p *CassandraDescribeSnitchResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeSnitchResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSnitchResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraDescribeSnitchResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_snitch_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSnitchResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSnitchResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSnitchResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeKeyspaceArgs struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
}

func NewCassandraDescribeKeyspaceArgs() *CassandraDescribeKeyspaceArgs {
  return &CassandraDescribeKeyspaceArgs{}
}


func (p *CassandraDescribeKeyspaceArgs) GetKeyspace() string {
  return p.Keyspace
}
func (p *CassandraDescribeKeyspaceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  return nil
}

func (p *CassandraDescribeKeyspaceArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CassandraDescribeKeyspaceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_keyspace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CassandraDescribeKeyspaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Nfe
//  - Ire
type CassandraDescribeKeyspaceResult struct {
  Success *KsDef `thrift:"success,0" db:"success" json:"success,omitempty"`
  Nfe *NotFoundException `thrift:"nfe,1" db:"nfe" json:"nfe,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,2" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeKeyspaceResult() *CassandraDescribeKeyspaceResult {
  return &CassandraDescribeKeyspaceResult{}
}

var CassandraDescribeKeyspaceResult_Success_DEFAULT *KsDef
func (p *CassandraDescribeKeyspaceResult) GetSuccess() *KsDef {
  if !p.IsSetSuccess() {
    return CassandraDescribeKeyspaceResult_Success_DEFAULT
  }
return p.Success
}
var CassandraDescribeKeyspaceResult_Nfe_DEFAULT *NotFoundException
func (p *CassandraDescribeKeyspaceResult) GetNfe() *NotFoundException {
  if !p.IsSetNfe() {
    return CassandraDescribeKeyspaceResult_Nfe_DEFAULT
  }
return p.Nfe
}
var CassandraDescribeKeyspaceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeKeyspaceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeKeyspaceResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeKeyspaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeKeyspaceResult) IsSetNfe() bool {
  return p.Nfe != nil
}

func (p *CassandraDescribeKeyspaceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeKeyspaceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspaceResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &KsDef{
  DurableWrites: true,
}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspaceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Nfe = &NotFoundException{}
  if err := p.Nfe.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Nfe), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspaceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeKeyspaceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_keyspace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetNfe() {
    if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nfe: ", p), err) }
    if err := p.Nfe.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Nfe), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nfe: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeKeyspaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
type CassandraDescribeSplitsArgs struct {
  CfName string `thrift:"cfName,1,required" db:"cfName" json:"cfName"`
  StartToken string `thrift:"start_token,2,required" db:"start_token" json:"start_token"`
  EndToken string `thrift:"end_token,3,required" db:"end_token" json:"end_token"`
  KeysPerSplit int32 `thrift:"keys_per_split,4,required" db:"keys_per_split" json:"keys_per_split"`
}

func NewCassandraDescribeSplitsArgs() *CassandraDescribeSplitsArgs {
  return &CassandraDescribeSplitsArgs{}
}


func (p *CassandraDescribeSplitsArgs) GetCfName() string {
  return p.CfName
}

func (p *CassandraDescribeSplitsArgs) GetStartToken() string {
  return p.StartToken
}

func (p *CassandraDescribeSplitsArgs) GetEndToken() string {
  return p.EndToken
}

func (p *CassandraDescribeSplitsArgs) GetKeysPerSplit() int32 {
  return p.KeysPerSplit
}
func (p *CassandraDescribeSplitsArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCfName bool = false;
  var issetStartToken bool = false;
  var issetEndToken bool = false;
  var issetKeysPerSplit bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfName = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartToken = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetEndToken = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeysPerSplit = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCfName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfName is not set"));
  }
  if !issetStartToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"));
  }
  if !issetEndToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"));
  }
  if !issetKeysPerSplit{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KeysPerSplit is not set"));
  }
  return nil
}

func (p *CassandraDescribeSplitsArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CfName = v
}
  return nil
}

func (p *CassandraDescribeSplitsArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StartToken = v
}
  return nil
}

func (p *CassandraDescribeSplitsArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.EndToken = v
}
  return nil
}

func (p *CassandraDescribeSplitsArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.KeysPerSplit = v
}
  return nil
}

func (p *CassandraDescribeSplitsArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_splits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfName: ", p), err) }
  if err := oprot.WriteString(string(p.CfName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cfName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfName: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_token: ", p), err) }
  if err := oprot.WriteString(string(p.StartToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_token (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_token: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:end_token: ", p), err) }
  if err := oprot.WriteString(string(p.EndToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.end_token (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:end_token: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:keys_per_split: ", p), err) }
  if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keys_per_split (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:keys_per_split: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSplitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSplitsResult struct {
  Success []string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeSplitsResult() *CassandraDescribeSplitsResult {
  return &CassandraDescribeSplitsResult{}
}

var CassandraDescribeSplitsResult_Success_DEFAULT []string

func (p *CassandraDescribeSplitsResult) GetSuccess() []string {
  return p.Success
}
var CassandraDescribeSplitsResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeSplitsResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeSplitsResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeSplitsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeSplitsResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeSplitsResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSplitsResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem158 string
    if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem158 = v
}
    p.Success = append(p.Success, _elem158)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraDescribeSplitsResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeSplitsResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_splits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteString(string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSplitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSplitsResult(%+v)", *p)
}

type CassandraTraceNextQueryArgs struct {
}

func NewCassandraTraceNextQueryArgs() *CassandraTraceNextQueryArgs {
  return &CassandraTraceNextQueryArgs{}
}

func (p *CassandraTraceNextQueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraTraceNextQueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("trace_next_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraTraceNextQueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraTraceNextQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraTraceNextQueryResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewCassandraTraceNextQueryResult() *CassandraTraceNextQueryResult {
  return &CassandraTraceNextQueryResult{}
}

var CassandraTraceNextQueryResult_Success_DEFAULT []byte

func (p *CassandraTraceNextQueryResult) GetSuccess() []byte {
  return p.Success
}
func (p *CassandraTraceNextQueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraTraceNextQueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraTraceNextQueryResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *CassandraTraceNextQueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("trace_next_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraTraceNextQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraTraceNextQueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraTraceNextQueryResult(%+v)", *p)
}

// Attributes:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
type CassandraDescribeSplitsExArgs struct {
  CfName string `thrift:"cfName,1,required" db:"cfName" json:"cfName"`
  StartToken string `thrift:"start_token,2,required" db:"start_token" json:"start_token"`
  EndToken string `thrift:"end_token,3,required" db:"end_token" json:"end_token"`
  KeysPerSplit int32 `thrift:"keys_per_split,4,required" db:"keys_per_split" json:"keys_per_split"`
}

func NewCassandraDescribeSplitsExArgs() *CassandraDescribeSplitsExArgs {
  return &CassandraDescribeSplitsExArgs{}
}


func (p *CassandraDescribeSplitsExArgs) GetCfName() string {
  return p.CfName
}

func (p *CassandraDescribeSplitsExArgs) GetStartToken() string {
  return p.StartToken
}

func (p *CassandraDescribeSplitsExArgs) GetEndToken() string {
  return p.EndToken
}

func (p *CassandraDescribeSplitsExArgs) GetKeysPerSplit() int32 {
  return p.KeysPerSplit
}
func (p *CassandraDescribeSplitsExArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCfName bool = false;
  var issetStartToken bool = false;
  var issetEndToken bool = false;
  var issetKeysPerSplit bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfName = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetStartToken = true
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetEndToken = true
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeysPerSplit = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCfName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfName is not set"));
  }
  if !issetStartToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"));
  }
  if !issetEndToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"));
  }
  if !issetKeysPerSplit{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KeysPerSplit is not set"));
  }
  return nil
}

func (p *CassandraDescribeSplitsExArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CfName = v
}
  return nil
}

func (p *CassandraDescribeSplitsExArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StartToken = v
}
  return nil
}

func (p *CassandraDescribeSplitsExArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.EndToken = v
}
  return nil
}

func (p *CassandraDescribeSplitsExArgs)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.KeysPerSplit = v
}
  return nil
}

func (p *CassandraDescribeSplitsExArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_splits_ex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSplitsExArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfName: ", p), err) }
  if err := oprot.WriteString(string(p.CfName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cfName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfName: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsExArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_token: ", p), err) }
  if err := oprot.WriteString(string(p.StartToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.start_token (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_token: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsExArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:end_token: ", p), err) }
  if err := oprot.WriteString(string(p.EndToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.end_token (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:end_token: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsExArgs) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:keys_per_split: ", p), err) }
  if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keys_per_split (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:keys_per_split: ", p), err) }
  return err
}

func (p *CassandraDescribeSplitsExArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSplitsExArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSplitsExResult struct {
  Success []*CfSplit `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraDescribeSplitsExResult() *CassandraDescribeSplitsExResult {
  return &CassandraDescribeSplitsExResult{}
}

var CassandraDescribeSplitsExResult_Success_DEFAULT []*CfSplit

func (p *CassandraDescribeSplitsExResult) GetSuccess() []*CfSplit {
  return p.Success
}
var CassandraDescribeSplitsExResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraDescribeSplitsExResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraDescribeSplitsExResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraDescribeSplitsExResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraDescribeSplitsExResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraDescribeSplitsExResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraDescribeSplitsExResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CfSplit, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem159 := &CfSplit{}
    if err := _elem159.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem159), err)
    }
    p.Success = append(p.Success, _elem159)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraDescribeSplitsExResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraDescribeSplitsExResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("describe_splits_ex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraDescribeSplitsExResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSplitsExResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraDescribeSplitsExResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraDescribeSplitsExResult(%+v)", *p)
}

// Attributes:
//  - CfDef
type CassandraSystemAddColumnFamilyArgs struct {
  CfDef *CfDef `thrift:"cf_def,1,required" db:"cf_def" json:"cf_def"`
}

func NewCassandraSystemAddColumnFamilyArgs() *CassandraSystemAddColumnFamilyArgs {
  return &CassandraSystemAddColumnFamilyArgs{}
}

var CassandraSystemAddColumnFamilyArgs_CfDef_DEFAULT *CfDef
func (p *CassandraSystemAddColumnFamilyArgs) GetCfDef() *CfDef {
  if !p.IsSetCfDef() {
    return CassandraSystemAddColumnFamilyArgs_CfDef_DEFAULT
  }
return p.CfDef
}
func (p *CassandraSystemAddColumnFamilyArgs) IsSetCfDef() bool {
  return p.CfDef != nil
}

func (p *CassandraSystemAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCfDef bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfDef = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCfDef{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDef is not set"));
  }
  return nil
}

func (p *CassandraSystemAddColumnFamilyArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.CfDef = &CfDef{
  ColumnType: "Standard",

  ComparatorType: "BytesType",

  Caching: "keys_only",

  SpeculativeRetry: "NONE",

  CellsPerRowToCache: "100",
}
  if err := p.CfDef.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CfDef), err)
  }
  return nil
}

func (p *CassandraSystemAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_add_column_family_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cf_def: ", p), err) }
  if err := p.CfDef.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CfDef), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cf_def: ", p), err) }
  return err
}

func (p *CassandraSystemAddColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemAddColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemAddColumnFamilyResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemAddColumnFamilyResult() *CassandraSystemAddColumnFamilyResult {
  return &CassandraSystemAddColumnFamilyResult{}
}

var CassandraSystemAddColumnFamilyResult_Success_DEFAULT string
func (p *CassandraSystemAddColumnFamilyResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemAddColumnFamilyResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemAddColumnFamilyResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemAddColumnFamilyResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemAddColumnFamilyResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemAddColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemAddColumnFamilyResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemAddColumnFamilyResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemAddColumnFamilyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemAddColumnFamilyResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemAddColumnFamilyResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemAddColumnFamilyResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemAddColumnFamilyResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemAddColumnFamilyResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_add_column_family_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemAddColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemAddColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - ColumnFamily
type CassandraSystemDropColumnFamilyArgs struct {
  ColumnFamily string `thrift:"column_family,1,required" db:"column_family" json:"column_family"`
}

func NewCassandraSystemDropColumnFamilyArgs() *CassandraSystemDropColumnFamilyArgs {
  return &CassandraSystemDropColumnFamilyArgs{}
}


func (p *CassandraSystemDropColumnFamilyArgs) GetColumnFamily() string {
  return p.ColumnFamily
}
func (p *CassandraSystemDropColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetColumnFamily bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetColumnFamily = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetColumnFamily{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"));
  }
  return nil
}

func (p *CassandraSystemDropColumnFamilyArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ColumnFamily = v
}
  return nil
}

func (p *CassandraSystemDropColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_drop_column_family_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemDropColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_family: ", p), err) }
  if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.column_family (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_family: ", p), err) }
  return err
}

func (p *CassandraSystemDropColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemDropColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemDropColumnFamilyResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemDropColumnFamilyResult() *CassandraSystemDropColumnFamilyResult {
  return &CassandraSystemDropColumnFamilyResult{}
}

var CassandraSystemDropColumnFamilyResult_Success_DEFAULT string
func (p *CassandraSystemDropColumnFamilyResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemDropColumnFamilyResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemDropColumnFamilyResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemDropColumnFamilyResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemDropColumnFamilyResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemDropColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemDropColumnFamilyResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemDropColumnFamilyResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemDropColumnFamilyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemDropColumnFamilyResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemDropColumnFamilyResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemDropColumnFamilyResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemDropColumnFamilyResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemDropColumnFamilyResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemDropColumnFamilyResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemDropColumnFamilyResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_drop_column_family_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemDropColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemDropColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - KsDef
type CassandraSystemAddKeyspaceArgs struct {
  KsDef *KsDef `thrift:"ks_def,1,required" db:"ks_def" json:"ks_def"`
}

func NewCassandraSystemAddKeyspaceArgs() *CassandraSystemAddKeyspaceArgs {
  return &CassandraSystemAddKeyspaceArgs{}
}

var CassandraSystemAddKeyspaceArgs_KsDef_DEFAULT *KsDef
func (p *CassandraSystemAddKeyspaceArgs) GetKsDef() *KsDef {
  if !p.IsSetKsDef() {
    return CassandraSystemAddKeyspaceArgs_KsDef_DEFAULT
  }
return p.KsDef
}
func (p *CassandraSystemAddKeyspaceArgs) IsSetKsDef() bool {
  return p.KsDef != nil
}

func (p *CassandraSystemAddKeyspaceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKsDef bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKsDef = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKsDef{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KsDef is not set"));
  }
  return nil
}

func (p *CassandraSystemAddKeyspaceArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.KsDef = &KsDef{
  DurableWrites: true,
}
  if err := p.KsDef.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.KsDef), err)
  }
  return nil
}

func (p *CassandraSystemAddKeyspaceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_add_keyspace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemAddKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ks_def: ", p), err) }
  if err := p.KsDef.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.KsDef), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ks_def: ", p), err) }
  return err
}

func (p *CassandraSystemAddKeyspaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemAddKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemAddKeyspaceResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemAddKeyspaceResult() *CassandraSystemAddKeyspaceResult {
  return &CassandraSystemAddKeyspaceResult{}
}

var CassandraSystemAddKeyspaceResult_Success_DEFAULT string
func (p *CassandraSystemAddKeyspaceResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemAddKeyspaceResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemAddKeyspaceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemAddKeyspaceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemAddKeyspaceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemAddKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemAddKeyspaceResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemAddKeyspaceResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemAddKeyspaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemAddKeyspaceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemAddKeyspaceResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemAddKeyspaceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemAddKeyspaceResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemAddKeyspaceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemAddKeyspaceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemAddKeyspaceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_add_keyspace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemAddKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemAddKeyspaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemAddKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraSystemDropKeyspaceArgs struct {
  Keyspace string `thrift:"keyspace,1,required" db:"keyspace" json:"keyspace"`
}

func NewCassandraSystemDropKeyspaceArgs() *CassandraSystemDropKeyspaceArgs {
  return &CassandraSystemDropKeyspaceArgs{}
}


func (p *CassandraSystemDropKeyspaceArgs) GetKeyspace() string {
  return p.Keyspace
}
func (p *CassandraSystemDropKeyspaceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKeyspace bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKeyspace = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKeyspace{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"));
  }
  return nil
}

func (p *CassandraSystemDropKeyspaceArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Keyspace = v
}
  return nil
}

func (p *CassandraSystemDropKeyspaceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_drop_keyspace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemDropKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err) }
  if err := oprot.WriteString(string(p.Keyspace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err) }
  return err
}

func (p *CassandraSystemDropKeyspaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemDropKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemDropKeyspaceResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemDropKeyspaceResult() *CassandraSystemDropKeyspaceResult {
  return &CassandraSystemDropKeyspaceResult{}
}

var CassandraSystemDropKeyspaceResult_Success_DEFAULT string
func (p *CassandraSystemDropKeyspaceResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemDropKeyspaceResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemDropKeyspaceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemDropKeyspaceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemDropKeyspaceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemDropKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemDropKeyspaceResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemDropKeyspaceResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemDropKeyspaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemDropKeyspaceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemDropKeyspaceResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemDropKeyspaceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemDropKeyspaceResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemDropKeyspaceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemDropKeyspaceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemDropKeyspaceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_drop_keyspace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemDropKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemDropKeyspaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemDropKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - KsDef
type CassandraSystemUpdateKeyspaceArgs struct {
  KsDef *KsDef `thrift:"ks_def,1,required" db:"ks_def" json:"ks_def"`
}

func NewCassandraSystemUpdateKeyspaceArgs() *CassandraSystemUpdateKeyspaceArgs {
  return &CassandraSystemUpdateKeyspaceArgs{}
}

var CassandraSystemUpdateKeyspaceArgs_KsDef_DEFAULT *KsDef
func (p *CassandraSystemUpdateKeyspaceArgs) GetKsDef() *KsDef {
  if !p.IsSetKsDef() {
    return CassandraSystemUpdateKeyspaceArgs_KsDef_DEFAULT
  }
return p.KsDef
}
func (p *CassandraSystemUpdateKeyspaceArgs) IsSetKsDef() bool {
  return p.KsDef != nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetKsDef bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetKsDef = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetKsDef{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KsDef is not set"));
  }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.KsDef = &KsDef{
  DurableWrites: true,
}
  if err := p.KsDef.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.KsDef), err)
  }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_update_keyspace_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ks_def: ", p), err) }
  if err := p.KsDef.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.KsDef), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ks_def: ", p), err) }
  return err
}

func (p *CassandraSystemUpdateKeyspaceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemUpdateKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemUpdateKeyspaceResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemUpdateKeyspaceResult() *CassandraSystemUpdateKeyspaceResult {
  return &CassandraSystemUpdateKeyspaceResult{}
}

var CassandraSystemUpdateKeyspaceResult_Success_DEFAULT string
func (p *CassandraSystemUpdateKeyspaceResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemUpdateKeyspaceResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemUpdateKeyspaceResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemUpdateKeyspaceResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemUpdateKeyspaceResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemUpdateKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemUpdateKeyspaceResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemUpdateKeyspaceResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemUpdateKeyspaceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemUpdateKeyspaceResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_update_keyspace_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateKeyspaceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemUpdateKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - CfDef
type CassandraSystemUpdateColumnFamilyArgs struct {
  CfDef *CfDef `thrift:"cf_def,1,required" db:"cf_def" json:"cf_def"`
}

func NewCassandraSystemUpdateColumnFamilyArgs() *CassandraSystemUpdateColumnFamilyArgs {
  return &CassandraSystemUpdateColumnFamilyArgs{}
}

var CassandraSystemUpdateColumnFamilyArgs_CfDef_DEFAULT *CfDef
func (p *CassandraSystemUpdateColumnFamilyArgs) GetCfDef() *CfDef {
  if !p.IsSetCfDef() {
    return CassandraSystemUpdateColumnFamilyArgs_CfDef_DEFAULT
  }
return p.CfDef
}
func (p *CassandraSystemUpdateColumnFamilyArgs) IsSetCfDef() bool {
  return p.CfDef != nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCfDef bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCfDef = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCfDef{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDef is not set"));
  }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.CfDef = &CfDef{
  ColumnType: "Standard",

  ComparatorType: "BytesType",

  Caching: "keys_only",

  SpeculativeRetry: "NONE",

  CellsPerRowToCache: "100",
}
  if err := p.CfDef.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CfDef), err)
  }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_update_column_family_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cf_def: ", p), err) }
  if err := p.CfDef.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CfDef), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cf_def: ", p), err) }
  return err
}

func (p *CassandraSystemUpdateColumnFamilyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemUpdateColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemUpdateColumnFamilyResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,2" db:"sde" json:"sde,omitempty"`
}

func NewCassandraSystemUpdateColumnFamilyResult() *CassandraSystemUpdateColumnFamilyResult {
  return &CassandraSystemUpdateColumnFamilyResult{}
}

var CassandraSystemUpdateColumnFamilyResult_Success_DEFAULT string
func (p *CassandraSystemUpdateColumnFamilyResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return CassandraSystemUpdateColumnFamilyResult_Success_DEFAULT
  }
return *p.Success
}
var CassandraSystemUpdateColumnFamilyResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSystemUpdateColumnFamilyResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSystemUpdateColumnFamilyResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraSystemUpdateColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraSystemUpdateColumnFamilyResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraSystemUpdateColumnFamilyResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraSystemUpdateColumnFamilyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult)  ReadField0(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("system_update_column_family_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err) }
  }
  return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSystemUpdateColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraExecuteCqlQueryArgs struct {
  Query []byte `thrift:"query,1,required" db:"query" json:"query"`
  Compression Compression `thrift:"compression,2,required" db:"compression" json:"compression"`
}

func NewCassandraExecuteCqlQueryArgs() *CassandraExecuteCqlQueryArgs {
  return &CassandraExecuteCqlQueryArgs{}
}


func (p *CassandraExecuteCqlQueryArgs) GetQuery() []byte {
  return p.Query
}

func (p *CassandraExecuteCqlQueryArgs) GetCompression() Compression {
  return p.Compression
}
func (p *CassandraExecuteCqlQueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetQuery bool = false;
  var issetCompression bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetQuery = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCompression = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetQuery{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
  }
  if !issetCompression{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"));
  }
  return nil
}

func (p *CassandraExecuteCqlQueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Query = v
}
  return nil
}

func (p *CassandraExecuteCqlQueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Compression(v)
  p.Compression = temp
}
  return nil
}

func (p *CassandraExecuteCqlQueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_cql_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecuteCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := oprot.WriteBinary(p.Query); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *CassandraExecuteCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err) }
  if err := oprot.WriteI32(int32(p.Compression)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err) }
  return err
}

func (p *CassandraExecuteCqlQueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecuteCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecuteCqlQueryResult struct {
  Success *CqlResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,4" db:"sde" json:"sde,omitempty"`
}

func NewCassandraExecuteCqlQueryResult() *CassandraExecuteCqlQueryResult {
  return &CassandraExecuteCqlQueryResult{}
}

var CassandraExecuteCqlQueryResult_Success_DEFAULT *CqlResult_
func (p *CassandraExecuteCqlQueryResult) GetSuccess() *CqlResult_ {
  if !p.IsSetSuccess() {
    return CassandraExecuteCqlQueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraExecuteCqlQueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraExecuteCqlQueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraExecuteCqlQueryResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraExecuteCqlQueryResult_Ue_DEFAULT *UnavailableException
func (p *CassandraExecuteCqlQueryResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraExecuteCqlQueryResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraExecuteCqlQueryResult_Te_DEFAULT *TimedOutException
func (p *CassandraExecuteCqlQueryResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraExecuteCqlQueryResult_Te_DEFAULT
  }
return p.Te
}
var CassandraExecuteCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraExecuteCqlQueryResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraExecuteCqlQueryResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraExecuteCqlQueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraExecuteCqlQueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult)  ReadField4(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraExecuteCqlQueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_cql_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecuteCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCqlQueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecuteCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
//  - Consistency
type CassandraExecuteCql3QueryArgs struct {
  Query []byte `thrift:"query,1,required" db:"query" json:"query"`
  Compression Compression `thrift:"compression,2,required" db:"compression" json:"compression"`
  Consistency ConsistencyLevel `thrift:"consistency,3,required" db:"consistency" json:"consistency"`
}

func NewCassandraExecuteCql3QueryArgs() *CassandraExecuteCql3QueryArgs {
  return &CassandraExecuteCql3QueryArgs{}
}


func (p *CassandraExecuteCql3QueryArgs) GetQuery() []byte {
  return p.Query
}

func (p *CassandraExecuteCql3QueryArgs) GetCompression() Compression {
  return p.Compression
}

func (p *CassandraExecuteCql3QueryArgs) GetConsistency() ConsistencyLevel {
  return p.Consistency
}
func (p *CassandraExecuteCql3QueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetQuery bool = false;
  var issetCompression bool = false;
  var issetConsistency bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetQuery = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCompression = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistency = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetQuery{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
  }
  if !issetCompression{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"));
  }
  if !issetConsistency{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Consistency is not set"));
  }
  return nil
}

func (p *CassandraExecuteCql3QueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Query = v
}
  return nil
}

func (p *CassandraExecuteCql3QueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Compression(v)
  p.Compression = temp
}
  return nil
}

func (p *CassandraExecuteCql3QueryArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.Consistency = temp
}
  return nil
}

func (p *CassandraExecuteCql3QueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_cql3_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecuteCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := oprot.WriteBinary(p.Query); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *CassandraExecuteCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err) }
  if err := oprot.WriteI32(int32(p.Compression)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err) }
  return err
}

func (p *CassandraExecuteCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency: ", p), err) }
  if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency: ", p), err) }
  return err
}

func (p *CassandraExecuteCql3QueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecuteCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecuteCql3QueryResult struct {
  Success *CqlResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,4" db:"sde" json:"sde,omitempty"`
}

func NewCassandraExecuteCql3QueryResult() *CassandraExecuteCql3QueryResult {
  return &CassandraExecuteCql3QueryResult{}
}

var CassandraExecuteCql3QueryResult_Success_DEFAULT *CqlResult_
func (p *CassandraExecuteCql3QueryResult) GetSuccess() *CqlResult_ {
  if !p.IsSetSuccess() {
    return CassandraExecuteCql3QueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraExecuteCql3QueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraExecuteCql3QueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraExecuteCql3QueryResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraExecuteCql3QueryResult_Ue_DEFAULT *UnavailableException
func (p *CassandraExecuteCql3QueryResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraExecuteCql3QueryResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraExecuteCql3QueryResult_Te_DEFAULT *TimedOutException
func (p *CassandraExecuteCql3QueryResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraExecuteCql3QueryResult_Te_DEFAULT
  }
return p.Te
}
var CassandraExecuteCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraExecuteCql3QueryResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraExecuteCql3QueryResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraExecuteCql3QueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraExecuteCql3QueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult)  ReadField4(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraExecuteCql3QueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_cql3_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecuteCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err) }
  }
  return err
}

func (p *CassandraExecuteCql3QueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecuteCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraPrepareCqlQueryArgs struct {
  Query []byte `thrift:"query,1,required" db:"query" json:"query"`
  Compression Compression `thrift:"compression,2,required" db:"compression" json:"compression"`
}

func NewCassandraPrepareCqlQueryArgs() *CassandraPrepareCqlQueryArgs {
  return &CassandraPrepareCqlQueryArgs{}
}


func (p *CassandraPrepareCqlQueryArgs) GetQuery() []byte {
  return p.Query
}

func (p *CassandraPrepareCqlQueryArgs) GetCompression() Compression {
  return p.Compression
}
func (p *CassandraPrepareCqlQueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetQuery bool = false;
  var issetCompression bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetQuery = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCompression = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetQuery{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
  }
  if !issetCompression{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"));
  }
  return nil
}

func (p *CassandraPrepareCqlQueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Query = v
}
  return nil
}

func (p *CassandraPrepareCqlQueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Compression(v)
  p.Compression = temp
}
  return nil
}

func (p *CassandraPrepareCqlQueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("prepare_cql_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraPrepareCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := oprot.WriteBinary(p.Query); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *CassandraPrepareCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err) }
  if err := oprot.WriteI32(int32(p.Compression)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err) }
  return err
}

func (p *CassandraPrepareCqlQueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraPrepareCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraPrepareCqlQueryResult struct {
  Success *CqlPreparedResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraPrepareCqlQueryResult() *CassandraPrepareCqlQueryResult {
  return &CassandraPrepareCqlQueryResult{}
}

var CassandraPrepareCqlQueryResult_Success_DEFAULT *CqlPreparedResult_
func (p *CassandraPrepareCqlQueryResult) GetSuccess() *CqlPreparedResult_ {
  if !p.IsSetSuccess() {
    return CassandraPrepareCqlQueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraPrepareCqlQueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraPrepareCqlQueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraPrepareCqlQueryResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraPrepareCqlQueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraPrepareCqlQueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraPrepareCqlQueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraPrepareCqlQueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlPreparedResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraPrepareCqlQueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraPrepareCqlQueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("prepare_cql_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraPrepareCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraPrepareCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraPrepareCqlQueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraPrepareCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraPrepareCql3QueryArgs struct {
  Query []byte `thrift:"query,1,required" db:"query" json:"query"`
  Compression Compression `thrift:"compression,2,required" db:"compression" json:"compression"`
}

func NewCassandraPrepareCql3QueryArgs() *CassandraPrepareCql3QueryArgs {
  return &CassandraPrepareCql3QueryArgs{}
}


func (p *CassandraPrepareCql3QueryArgs) GetQuery() []byte {
  return p.Query
}

func (p *CassandraPrepareCql3QueryArgs) GetCompression() Compression {
  return p.Compression
}
func (p *CassandraPrepareCql3QueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetQuery bool = false;
  var issetCompression bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetQuery = true
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetCompression = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetQuery{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
  }
  if !issetCompression{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"));
  }
  return nil
}

func (p *CassandraPrepareCql3QueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Query = v
}
  return nil
}

func (p *CassandraPrepareCql3QueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Compression(v)
  p.Compression = temp
}
  return nil
}

func (p *CassandraPrepareCql3QueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("prepare_cql3_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraPrepareCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := oprot.WriteBinary(p.Query); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *CassandraPrepareCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err) }
  if err := oprot.WriteI32(int32(p.Compression)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err) }
  return err
}

func (p *CassandraPrepareCql3QueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraPrepareCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraPrepareCql3QueryResult struct {
  Success *CqlPreparedResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraPrepareCql3QueryResult() *CassandraPrepareCql3QueryResult {
  return &CassandraPrepareCql3QueryResult{}
}

var CassandraPrepareCql3QueryResult_Success_DEFAULT *CqlPreparedResult_
func (p *CassandraPrepareCql3QueryResult) GetSuccess() *CqlPreparedResult_ {
  if !p.IsSetSuccess() {
    return CassandraPrepareCql3QueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraPrepareCql3QueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraPrepareCql3QueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraPrepareCql3QueryResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraPrepareCql3QueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraPrepareCql3QueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraPrepareCql3QueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraPrepareCql3QueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlPreparedResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraPrepareCql3QueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraPrepareCql3QueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("prepare_cql3_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraPrepareCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraPrepareCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraPrepareCql3QueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraPrepareCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Values
type CassandraExecutePreparedCqlQueryArgs struct {
  ItemId int32 `thrift:"itemId,1,required" db:"itemId" json:"itemId"`
  Values [][]byte `thrift:"values,2,required" db:"values" json:"values"`
}

func NewCassandraExecutePreparedCqlQueryArgs() *CassandraExecutePreparedCqlQueryArgs {
  return &CassandraExecutePreparedCqlQueryArgs{}
}


func (p *CassandraExecutePreparedCqlQueryArgs) GetItemId() int32 {
  return p.ItemId
}

func (p *CassandraExecutePreparedCqlQueryArgs) GetValues() [][]byte {
  return p.Values
}
func (p *CassandraExecutePreparedCqlQueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetItemId bool = false;
  var issetValues bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetItemId = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValues = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetItemId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"));
  }
  if !issetValues{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Values is not set"));
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ItemId = v
}
  return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
var _elem160 []byte
    if v, err := iprot.ReadBinary(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem160 = v
}
    p.Values = append(p.Values, _elem160)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_prepared_cql_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err) }
  if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err) }
  return err
}

func (p *CassandraExecutePreparedCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := oprot.WriteBinary(v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err) }
  return err
}

func (p *CassandraExecutePreparedCqlQueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecutePreparedCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecutePreparedCqlQueryResult struct {
  Success *CqlResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,4" db:"sde" json:"sde,omitempty"`
}

func NewCassandraExecutePreparedCqlQueryResult() *CassandraExecutePreparedCqlQueryResult {
  return &CassandraExecutePreparedCqlQueryResult{}
}

var CassandraExecutePreparedCqlQueryResult_Success_DEFAULT *CqlResult_
func (p *CassandraExecutePreparedCqlQueryResult) GetSuccess() *CqlResult_ {
  if !p.IsSetSuccess() {
    return CassandraExecutePreparedCqlQueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraExecutePreparedCqlQueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraExecutePreparedCqlQueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraExecutePreparedCqlQueryResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraExecutePreparedCqlQueryResult_Ue_DEFAULT *UnavailableException
func (p *CassandraExecutePreparedCqlQueryResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraExecutePreparedCqlQueryResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraExecutePreparedCqlQueryResult_Te_DEFAULT *TimedOutException
func (p *CassandraExecutePreparedCqlQueryResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraExecutePreparedCqlQueryResult_Te_DEFAULT
  }
return p.Te
}
var CassandraExecutePreparedCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraExecutePreparedCqlQueryResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraExecutePreparedCqlQueryResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraExecutePreparedCqlQueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult)  ReadField4(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_prepared_cql_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCqlQueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecutePreparedCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Values
//  - Consistency
type CassandraExecutePreparedCql3QueryArgs struct {
  ItemId int32 `thrift:"itemId,1,required" db:"itemId" json:"itemId"`
  Values [][]byte `thrift:"values,2,required" db:"values" json:"values"`
  Consistency ConsistencyLevel `thrift:"consistency,3,required" db:"consistency" json:"consistency"`
}

func NewCassandraExecutePreparedCql3QueryArgs() *CassandraExecutePreparedCql3QueryArgs {
  return &CassandraExecutePreparedCql3QueryArgs{}
}


func (p *CassandraExecutePreparedCql3QueryArgs) GetItemId() int32 {
  return p.ItemId
}

func (p *CassandraExecutePreparedCql3QueryArgs) GetValues() [][]byte {
  return p.Values
}

func (p *CassandraExecutePreparedCql3QueryArgs) GetConsistency() ConsistencyLevel {
  return p.Consistency
}
func (p *CassandraExecutePreparedCql3QueryArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetItemId bool = false;
  var issetValues bool = false;
  var issetConsistency bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetItemId = true
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetValues = true
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetConsistency = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetItemId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"));
  }
  if !issetValues{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Values is not set"));
  }
  if !issetConsistency{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Consistency is not set"));
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ItemId = v
}
  return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
var _elem161 []byte
    if v, err := iprot.ReadBinary(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem161 = v
}
    p.Values = append(p.Values, _elem161)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ConsistencyLevel(v)
  p.Consistency = temp
}
  return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_prepared_cql3_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err) }
  if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err) }
  return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := oprot.WriteBinary(v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err) }
  return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency: ", p), err) }
  if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consistency (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency: ", p), err) }
  return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecutePreparedCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecutePreparedCql3QueryResult struct {
  Success *CqlResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
  Ue *UnavailableException `thrift:"ue,2" db:"ue" json:"ue,omitempty"`
  Te *TimedOutException `thrift:"te,3" db:"te" json:"te,omitempty"`
  Sde *SchemaDisagreementException `thrift:"sde,4" db:"sde" json:"sde,omitempty"`
}

func NewCassandraExecutePreparedCql3QueryResult() *CassandraExecutePreparedCql3QueryResult {
  return &CassandraExecutePreparedCql3QueryResult{}
}

var CassandraExecutePreparedCql3QueryResult_Success_DEFAULT *CqlResult_
func (p *CassandraExecutePreparedCql3QueryResult) GetSuccess() *CqlResult_ {
  if !p.IsSetSuccess() {
    return CassandraExecutePreparedCql3QueryResult_Success_DEFAULT
  }
return p.Success
}
var CassandraExecutePreparedCql3QueryResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraExecutePreparedCql3QueryResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraExecutePreparedCql3QueryResult_Ire_DEFAULT
  }
return p.Ire
}
var CassandraExecutePreparedCql3QueryResult_Ue_DEFAULT *UnavailableException
func (p *CassandraExecutePreparedCql3QueryResult) GetUe() *UnavailableException {
  if !p.IsSetUe() {
    return CassandraExecutePreparedCql3QueryResult_Ue_DEFAULT
  }
return p.Ue
}
var CassandraExecutePreparedCql3QueryResult_Te_DEFAULT *TimedOutException
func (p *CassandraExecutePreparedCql3QueryResult) GetTe() *TimedOutException {
  if !p.IsSetTe() {
    return CassandraExecutePreparedCql3QueryResult_Te_DEFAULT
  }
return p.Te
}
var CassandraExecutePreparedCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException
func (p *CassandraExecutePreparedCql3QueryResult) GetSde() *SchemaDisagreementException {
  if !p.IsSetSde() {
    return CassandraExecutePreparedCql3QueryResult_Sde_DEFAULT
  }
return p.Sde
}
func (p *CassandraExecutePreparedCql3QueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetUe() bool {
  return p.Ue != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetTe() bool {
  return p.Te != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetSde() bool {
  return p.Sde != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult)  ReadField0(iprot thrift.TProtocol) error {
  p.Success = &CqlResult_{}
  if err := p.Success.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult)  ReadField2(iprot thrift.TProtocol) error {
  p.Ue = &UnavailableException{}
  if err := p.Ue.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult)  ReadField3(iprot thrift.TProtocol) error {
  p.Te = &TimedOutException{}
  if err := p.Te.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult)  ReadField4(iprot thrift.TProtocol) error {
  p.Sde = &SchemaDisagreementException{}
  if err := p.Sde.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
  }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("execute_prepared_cql3_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetUe() {
    if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err) }
    if err := p.Ue.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetTe() {
    if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err) }
    if err := p.Te.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
  if p.IsSetSde() {
    if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err) }
    if err := p.Sde.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err) }
  }
  return err
}

func (p *CassandraExecutePreparedCql3QueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraExecutePreparedCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - Version
type CassandraSetCqlVersionArgs struct {
  Version string `thrift:"version,1,required" db:"version" json:"version"`
}

func NewCassandraSetCqlVersionArgs() *CassandraSetCqlVersionArgs {
  return &CassandraSetCqlVersionArgs{}
}


func (p *CassandraSetCqlVersionArgs) GetVersion() string {
  return p.Version
}
func (p *CassandraSetCqlVersionArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetVersion bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetVersion = true
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetVersion{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Version is not set"));
  }
  return nil
}

func (p *CassandraSetCqlVersionArgs)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Version = v
}
  return nil
}

func (p *CassandraSetCqlVersionArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("set_cql_version_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSetCqlVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("version", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:version: ", p), err) }
  if err := oprot.WriteString(string(p.Version)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.version (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:version: ", p), err) }
  return err
}

func (p *CassandraSetCqlVersionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSetCqlVersionArgs(%+v)", *p)
}

// Attributes:
//  - Ire
type CassandraSetCqlVersionResult struct {
  Ire *InvalidRequestException `thrift:"ire,1" db:"ire" json:"ire,omitempty"`
}

func NewCassandraSetCqlVersionResult() *CassandraSetCqlVersionResult {
  return &CassandraSetCqlVersionResult{}
}

var CassandraSetCqlVersionResult_Ire_DEFAULT *InvalidRequestException
func (p *CassandraSetCqlVersionResult) GetIre() *InvalidRequestException {
  if !p.IsSetIre() {
    return CassandraSetCqlVersionResult_Ire_DEFAULT
  }
return p.Ire
}
func (p *CassandraSetCqlVersionResult) IsSetIre() bool {
  return p.Ire != nil
}

func (p *CassandraSetCqlVersionResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CassandraSetCqlVersionResult)  ReadField1(iprot thrift.TProtocol) error {
  p.Ire = &InvalidRequestException{}
  if err := p.Ire.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
  }
  return nil
}

func (p *CassandraSetCqlVersionResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("set_cql_version_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CassandraSetCqlVersionResult) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIre() {
    if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err) }
    if err := p.Ire.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err) }
  }
  return err
}

func (p *CassandraSetCqlVersionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CassandraSetCqlVersionResult(%+v)", *p)
}


